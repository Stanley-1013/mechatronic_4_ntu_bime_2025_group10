# V3 自走吸塵車 - 系統設計 (SD)

**版本**: 2.0
**日期**: 2025-12-07
**關聯文件**: 01_SRS, 02_SA

---

## 1. 設計概述

### 1.1 設計目標

基於 SA 的連續控制（行為融合）架構，本文件定義具體的軟體設計。

**核心設計原則**：
1. **Arduino 自主控制** - 所有即時控制邏輯在 Arduino 執行
2. **雙右側超音波** - 計算車身與牆壁夾角，實現精準沿牆與轉彎控制
3. **極簡通訊** - Pi 僅發送吸塵器控制指令
4. **距離+角度雙控制** - 同時修正距離誤差和車身角度

### 1.2 軟體架構

```
┌─────────────────────────────────────────────────────────────┐
│                      Arduino Uno                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌───────────────────────────────────────────────────────┐  │
│  │                    main.ino                           │  │
│  │  - setup()                                            │  │
│  │  - loop() [20Hz 主迴圈]                               │  │
│  └───────────────────────────────────────────────────────┘  │
│                            │                                │
│         ┌──────────────────┼──────────────────┐            │
│         ▼                  ▼                  ▼            │
│  ┌─────────────┐   ┌─────────────┐   ┌─────────────┐       │
│  │ ultrasonic  │   │ behavior    │   │ motor       │       │
│  │ .h/.cpp     │   │ .h/.cpp     │   │ .h/.cpp     │       │
│  │             │   │             │   │             │       │
│  │ - 前方 US   │   │ - wall()    │   │ - set()     │       │
│  │ - 右前 US   │   │ - turn()    │   │ - stop()    │       │
│  │ - 右後 US   │   │ - exit()    │   │             │       │
│  │ - 角度計算  │   │ - 距離+角度 │   │             │       │
│  └─────────────┘   └─────────────┘   └─────────────┘       │
│                                                             │
│  ┌─────────────┐   ┌─────────────┐                         │
│  │ vacuum      │   │ serial_cmd  │                         │
│  │ .h/.cpp     │   │ .h/.cpp     │                         │
│  │             │   │             │                         │
│  │ - on()      │   │ - check()   │                         │
│  │ - off()     │   │ - parse()   │                         │
│  └─────────────┘   └─────────────┘                         │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 1.3 雙右側超音波設計

```
俯視圖：
                        牆壁
    ─────────────────────────────────────

             d_front         d_rear
               ↓               ↓
    ┌──────────●───────────────●──────┐
    │       右前 US          右後 US   │
    │          ←───── L ─────→        │
    │                                  │
    │            車身                  │
    │                                  │
    └──────────────────────────────────┘
              ↑
           前方 US

L = 超音波間距 (約 15cm)
角度 = atan2(d_front - d_rear, L) × 180 / π

角度正 = 車頭朝向牆 (需左修正)
角度負 = 車尾朝向牆 (需右修正)
```

**設計優勢**：
1. **精準角度** - 直接測量車身與牆壁夾角，無漂移問題
2. **轉彎判斷** - 角度變化可判斷轉彎完成度
3. **穩定沿牆** - 同時修正距離和角度，不會斜向撞牆

---

## 2. Arduino 模組設計

### 2.1 config.h - 參數定義

```cpp
#ifndef CONFIG_H
#define CONFIG_H

// ============ 腳位定義 ============
// L298N 馬達驅動
#define PIN_ENA     3   // 左輪 PWM
#define PIN_IN1     6   // 左輪方向 A
#define PIN_IN2     5   // 左輪方向 B
#define PIN_ENB     11  // 右輪 PWM
#define PIN_IN3     10  // 右輪方向 A
#define PIN_IN4     9   // 右輪方向 B

// 超聲波 (3 個)
#define PIN_FRONT_TRIG      7
#define PIN_FRONT_ECHO      8
#define PIN_RIGHT_F_TRIG    A1      // 右前
#define PIN_RIGHT_F_ECHO    A2
#define PIN_RIGHT_R_TRIG    D2      // 右後 (新增)
#define PIN_RIGHT_R_ECHO    D4

// 吸塵器繼電器
#define PIN_VACUUM      A3

// ============ 雙超音波參數 ============
#define US_SPACING      15.0f   // 右側兩超音波間距 (cm)

// ============ 控制參數 ============
// 主迴圈
#define LOOP_INTERVAL   50      // 50ms = 20Hz

// 超聲波
#define US_TIMEOUT      8000    // 8ms 超時 (~136cm)
#define US_MIN_VALID    2       // 最小有效值 cm
#define US_MAX_VALID    200     // 最大有效值 cm

// 沿牆行為 (距離 + 角度雙控制)
#define TARGET_DIST     15.0f   // 目標右側距離 cm
#define TARGET_ANGLE    0.0f    // 目標角度 (平行牆壁)
#define KP_DIST         0.03f   // 距離比例增益
#define KP_ANGLE        0.02f   // 角度比例增益 (deg → angular)
#define MAX_ANGULAR     0.4f    // 最大轉向幅度

// 前方避障
#define FRONT_STOP      15.0f   // 觸發轉彎距離
#define FRONT_SLOW      30.0f   // 減速距離 cm

// 轉彎行為 (基於角度判斷)
#define TURN_TARGET     90.0f   // 目標轉彎角度 (度)
#define TURN_TOLERANCE  10.0f   // 角度容許誤差 (度)
#define TURN_TIMEOUT    50      // 轉彎超時 (2.5秒)
#define TURN_STABLE     15      // 穩定期 (750ms)

// 出場行為
#define EXIT_THRESHOLD      50.0f   // 右側無牆距離 cm
#define EXIT_FRONT_CLEAR    60.0f   // 前方暢通距離 cm
#define EXIT_WINDOW_MIN     2000    // 出場窗口最小 ms
#define EXIT_WINDOW_MAX     15000   // 出場窗口最大 ms
#define EXIT_CONFIRM        6       // 確認計數 (300ms)
#define EXIT_TURN           22      // 右轉結束
#define EXIT_TOTAL          62      // 總出場

// 馬達
#define BASE_PWM        60      // 基礎 PWM
#define TURN_PWM        50      // 原地轉彎 PWM (降低以便精確控制)
#define MIN_PWM         45      // 最小有效 PWM
#define LEFT_SCALE      1.0f    // 左輪比例 (調校用)
#define RIGHT_SCALE     1.0f    // 右輪比例 (調校用)

// 超時保護
#define RUN_TIMEOUT     300000  // 5 分鐘

#endif
```

### 2.2 ultrasonic.h/.cpp - 超聲波模組

```cpp
// ultrasonic.h - 三超音波管理 + 角度計算
#ifndef ULTRASONIC_H
#define ULTRASONIC_H

#include <Arduino.h>

// 感測器資料結構
struct SensorData {
    int front;          // 前方距離 (cm)
    int rightFront;     // 右前距離 (cm)
    int rightRear;      // 右後距離 (cm)
    float rightAvg;     // 右側平均距離 (cm)
    float angle;        // 車身與牆夾角 (度), 正=車頭朝牆
    bool rightValid;    // 右側資料是否有效
};

class UltrasonicManager {
public:
    void init();
    void update();                      // 輪流讀取 (每次呼叫讀一個)
    SensorData getData();               // 取得所有感測器資料

private:
    int _readOne(int trigPin, int echoPin);
    int _filter(int* history, int value);

    // 原始讀值
    int _front, _rightF, _rightR;

    // 中值濾波歷史
    int _histFront[3], _histRightF[3], _histRightR[3];

    // 輪流讀取狀態 (0=前, 1=右前, 2=右後)
    int _readIndex;
};

#endif
```

```cpp
// ultrasonic.cpp
#include "ultrasonic.h"
#include "config.h"

void UltrasonicManager::init() {
    pinMode(PIN_FRONT_TRIG, OUTPUT);
    pinMode(PIN_FRONT_ECHO, INPUT);
    pinMode(PIN_RIGHT_F_TRIG, OUTPUT);
    pinMode(PIN_RIGHT_F_ECHO, INPUT);
    pinMode(PIN_RIGHT_R_TRIG, OUTPUT);
    pinMode(PIN_RIGHT_R_ECHO, INPUT);

    // 初始化歷史
    for (int i = 0; i < 3; i++) {
        _histFront[i] = 100;
        _histRightF[i] = TARGET_DIST;
        _histRightR[i] = TARGET_DIST;
    }
    _front = 100;
    _rightF = TARGET_DIST;
    _rightR = TARGET_DIST;
    _readIndex = 0;
}

void UltrasonicManager::update() {
    // 輪流讀取，避免超音波互相干擾
    int val;
    switch (_readIndex) {
        case 0:
            val = _readOne(PIN_FRONT_TRIG, PIN_FRONT_ECHO);
            if (val > 0) _front = _filter(_histFront, val);
            break;
        case 1:
            val = _readOne(PIN_RIGHT_F_TRIG, PIN_RIGHT_F_ECHO);
            if (val > 0) _rightF = _filter(_histRightF, val);
            break;
        case 2:
            val = _readOne(PIN_RIGHT_R_TRIG, PIN_RIGHT_R_ECHO);
            if (val > 0) _rightR = _filter(_histRightR, val);
            break;
    }
    _readIndex = (_readIndex + 1) % 3;
}

SensorData UltrasonicManager::getData() {
    SensorData data;
    data.front = _front;
    data.rightFront = _rightF;
    data.rightRear = _rightR;

    // 計算右側平均距離
    data.rightAvg = (_rightF + _rightR) / 2.0f;

    // 計算角度 (需兩個右側都在有效範圍)
    bool fValid = (_rightF >= US_MIN_VALID && _rightF <= 50);
    bool rValid = (_rightR >= US_MIN_VALID && _rightR <= 50);

    if (fValid && rValid) {
        // angle = atan2(前-後, 間距) * 180 / PI
        // 正角度 = 車頭朝向牆
        data.angle = atan2(_rightF - _rightR, US_SPACING) * 57.2958f;
        data.rightValid = true;
    } else {
        data.angle = 0;
        data.rightValid = false;
    }

    return data;
}

int UltrasonicManager::_readOne(int trigPin, int echoPin) {
    digitalWrite(trigPin, LOW);
    delayMicroseconds(2);
    digitalWrite(trigPin, HIGH);
    delayMicroseconds(10);
    digitalWrite(trigPin, LOW);

    long duration = pulseIn(echoPin, HIGH, US_TIMEOUT);
    if (duration == 0) return -1;

    int dist = duration / 58;
    if (dist < US_MIN_VALID || dist > US_MAX_VALID) return -1;
    return dist;
}

int UltrasonicManager::_filter(int* history, int value) {
    // 移入新值
    history[2] = history[1];
    history[1] = history[0];
    history[0] = value;

    // 中值濾波
    int a = history[0], b = history[1], c = history[2];
    if (a > b) { int t = a; a = b; b = t; }
    if (b > c) { int t = b; b = c; c = t; }
    if (a > b) { int t = a; a = b; b = t; }
    return b;
}
```

### 2.3 behavior.h/.cpp - 行為控制模組 (距離+角度雙控制)

```cpp
// behavior.h
#ifndef BEHAVIOR_H
#define BEHAVIOR_H

#include <avr/wdt.h>
#include "ultrasonic.h"  // for SensorData

struct MotorCommand {
    int leftPWM;        // -255 ~ +255
    int rightPWM;       // -255 ~ +255
    bool stop;
};

class BehaviorController {
public:
    void init();
    MotorCommand update(const SensorData& sensor);

    int getCornerCount() { return _cornerCount; }
    bool isTurning() { return _isTurning; }
    bool isComplete() { return _complete; }

private:
    MotorCommand _handleTurning(const SensorData& sensor);
    MotorCommand _handleExit(const SensorData& sensor);
    MotorCommand _handleWallFollow(const SensorData& sensor);

    // 狀態
    int _cornerCount;
    bool _isTurning;
    float _turnStartAngle;  // 轉彎開始時的累計角度
    float _accumulatedAngle; // 累計轉過的角度
    int _turnTimer;
    int _stableTimer;
    float _exitCounter;
    bool _complete;
    unsigned long _startTime;
    unsigned long _exitSearchStart;
};

#endif
```

```cpp
// behavior.cpp - 距離+角度雙控制
#include "behavior.h"
#include "config.h"
#include <Arduino.h>

void BehaviorController::init() {
    _cornerCount = 0;
    _isTurning = false;
    _turnStartAngle = 0;
    _accumulatedAngle = 0;
    _turnTimer = 0;
    _stableTimer = 0;
    _exitCounter = 0;
    _complete = false;
    _startTime = millis();
    _exitSearchStart = 0;
    wdt_enable(WDTO_2S);
}

MotorCommand BehaviorController::update(const SensorData& sensor) {
    wdt_reset();

    // 超時保護
    if (millis() - _startTime > RUN_TIMEOUT) {
        _complete = true;
        return {0, 0, true};
    }

    if (_complete) return {0, 0, true};

    // 穩定期
    if (_stableTimer > 0) {
        _stableTimer--;
        return _handleWallFollow(sensor);
    }

    // 優先級 1: 轉彎
    if (_isTurning || sensor.front < FRONT_STOP) {
        return _handleTurning(sensor);
    }

    // 優先級 2: 出場 (略，與之前類似)

    // 優先級 3: 沿牆
    return _handleWallFollow(sensor);
}

// ===== 轉彎控制 (基於角度) =====
MotorCommand BehaviorController::_handleTurning(const SensorData& sensor) {
    if (!_isTurning) {
        _isTurning = true;
        _turnTimer = 0;
        _accumulatedAngle = 0;
    }

    _turnTimer++;

    // 超時保護
    if (_turnTimer > TURN_TIMEOUT) {
        _isTurning = false;
        _stableTimer = TURN_STABLE;
        _cornerCount++;
        if (_cornerCount == 4) _exitSearchStart = millis();
        return _handleWallFollow(sensor);
    }

    // 轉彎完成條件:
    // 1. 前方暢通 (>40cm)
    // 2. 右側有牆且角度接近 0 (平行)
    bool frontClear = (sensor.front > 40);
    bool aligned = sensor.rightValid && (abs(sensor.angle) < TURN_TOLERANCE);
    bool rightInRange = (sensor.rightAvg > 10 && sensor.rightAvg < 40);

    if (frontClear && aligned && rightInRange) {
        _isTurning = false;
        _stableTimer = TURN_STABLE;
        _cornerCount++;
        if (_cornerCount == 4) _exitSearchStart = millis();
        return _handleWallFollow(sensor);
    }

    // 慢速左轉
    return {-TURN_PWM, +TURN_PWM, false};
}

// ===== 沿牆控制 (距離+角度) =====
MotorCommand BehaviorController::_handleWallFollow(const SensorData& sensor) {
    float angular = 0;

    if (sensor.rightValid) {
        // 距離誤差
        float distError = TARGET_DIST - sensor.rightAvg;
        float distTerm = KP_DIST * distError;

        // 角度誤差 (目標 0 度 = 平行)
        float angleError = TARGET_ANGLE - sensor.angle;
        float angleTerm = KP_ANGLE * angleError;

        angular = distTerm + angleTerm;
    } else {
        // 右側無效，用找牆邏輯
        angular = -0.15f;  // 輕微右轉找牆
    }

    // 前方減速
    float speedScale = 1.0f;
    if (sensor.front < FRONT_SLOW) {
        speedScale = 0.5f + 0.5f * (sensor.front / FRONT_SLOW);
    }

    // 限幅
    if (angular > MAX_ANGULAR) angular = MAX_ANGULAR;
    if (angular < -MAX_ANGULAR) angular = -MAX_ANGULAR;

    // 轉換 PWM
    int basePWM = (int)(BASE_PWM * speedScale);
    int leftPWM = (int)(basePWM * (1.0f - angular));
    int rightPWM = (int)(basePWM * (1.0f + angular));

    // 馬達校正
    leftPWM = (int)(leftPWM * LEFT_SCALE);
    rightPWM = (int)(rightPWM * RIGHT_SCALE);

    // 限幅
    if (leftPWM > 0 && leftPWM < MIN_PWM) leftPWM = MIN_PWM;
    if (rightPWM > 0 && rightPWM < MIN_PWM) rightPWM = MIN_PWM;
    if (leftPWM > 255) leftPWM = 255;
    if (rightPWM > 255) rightPWM = 255;

    return {leftPWM, rightPWM, false};
}

// _handleExit 與之前類似，略
```

**控制邏輯說明**：

| 情況 | distError | angleError | 動作 |
|------|-----------|------------|------|
| 太近且車頭朝牆 | 正 | 負 | 強力左轉遠離 |
| 太近但平行 | 正 | 0 | 左轉遠離 |
| 太遠且車頭背牆 | 負 | 正 | 強力右轉靠近 |
| 距離OK但車頭朝牆 | 0 | 負 | 輕微左轉修正 |
| 距離OK且平行 | 0 | 0 | 直走 |

### 2.4 motor.h/.cpp - 馬達驅動模組

```cpp
// motor.h
#ifndef MOTOR_H
#define MOTOR_H

class Motor {
public:
    void init();
    void set(int leftPWM, int rightPWM);
    void stop();

private:
    void _setLeft(int pwm);
    void _setRight(int pwm);
};

#endif
```

```cpp
// motor.cpp
#include "motor.h"
#include "config.h"
#include <Arduino.h>

void Motor::init() {
    pinMode(PIN_ENA, OUTPUT);
    pinMode(PIN_IN1, OUTPUT);
    pinMode(PIN_IN2, OUTPUT);
    pinMode(PIN_ENB, OUTPUT);
    pinMode(PIN_IN3, OUTPUT);
    pinMode(PIN_IN4, OUTPUT);

    stop();
}

void Motor::set(int leftPWM, int rightPWM) {
    _setLeft(leftPWM);
    _setRight(rightPWM);
}

void Motor::stop() {
    analogWrite(PIN_ENA, 0);
    analogWrite(PIN_ENB, 0);
    digitalWrite(PIN_IN1, LOW);
    digitalWrite(PIN_IN2, LOW);
    digitalWrite(PIN_IN3, LOW);
    digitalWrite(PIN_IN4, LOW);
}

void Motor::_setLeft(int pwm) {
    if (pwm > 0) {
        // 前進
        digitalWrite(PIN_IN1, HIGH);
        digitalWrite(PIN_IN2, LOW);
        analogWrite(PIN_ENA, pwm);
    } else if (pwm < 0) {
        // 後退
        digitalWrite(PIN_IN1, LOW);
        digitalWrite(PIN_IN2, HIGH);
        analogWrite(PIN_ENA, -pwm);
    } else {
        // 停止
        digitalWrite(PIN_IN1, LOW);
        digitalWrite(PIN_IN2, LOW);
        analogWrite(PIN_ENA, 0);
    }
}

void Motor::_setRight(int pwm) {
    if (pwm > 0) {
        // 前進
        digitalWrite(PIN_IN3, HIGH);
        digitalWrite(PIN_IN4, LOW);
        analogWrite(PIN_ENB, pwm);
    } else if (pwm < 0) {
        // 後退
        digitalWrite(PIN_IN3, LOW);
        digitalWrite(PIN_IN4, HIGH);
        analogWrite(PIN_ENB, -pwm);
    } else {
        // 停止
        digitalWrite(PIN_IN3, LOW);
        digitalWrite(PIN_IN4, LOW);
        analogWrite(PIN_ENB, 0);
    }
}
```

### 2.5 vacuum.h/.cpp - 吸塵器模組

```cpp
// vacuum.h
#ifndef VACUUM_H
#define VACUUM_H

class Vacuum {
public:
    void init();
    void on();
    void off();
    bool isOn() { return _isOn; }

private:
    bool _isOn;
};

#endif
```

```cpp
// vacuum.cpp
#include "vacuum.h"
#include "config.h"
#include <Arduino.h>

void Vacuum::init() {
    pinMode(PIN_VACUUM, OUTPUT);
    off();
}

void Vacuum::on() {
    digitalWrite(PIN_VACUUM, HIGH);
    _isOn = true;
}

void Vacuum::off() {
    digitalWrite(PIN_VACUUM, LOW);
    _isOn = false;
}
```

### 2.6 serial_cmd.h/.cpp - 指令處理模組

```cpp
// serial_cmd.h
#ifndef SERIAL_CMD_H
#define SERIAL_CMD_H

// 指令定義
#define CMD_VACUUM_ON   0x01
#define CMD_VACUUM_OFF  0x02

// 封包格式
#define PKT_HEADER      0xAA
#define PKT_FOOTER      0x55

class SerialCommand {
public:
    void init(long baudRate);
    bool check();           // 檢查是否有新指令
    byte getCommand();      // 取得指令

private:
    byte _buffer[4];
    int _bufIndex;
    byte _lastCommand;
    bool _hasCommand;
};

#endif
```

```cpp
// serial_cmd.cpp
#include "serial_cmd.h"
#include <Arduino.h>

void SerialCommand::init(long baudRate) {
    Serial.begin(baudRate);
    _bufIndex = 0;
    _lastCommand = 0;
    _hasCommand = false;
}

bool SerialCommand::check() {
    _hasCommand = false;

    while (Serial.available()) {
        byte b = Serial.read();

        // 尋找封包頭
        if (_bufIndex == 0) {
            if (b == PKT_HEADER) {
                _buffer[_bufIndex++] = b;
            }
            continue;
        }

        _buffer[_bufIndex++] = b;

        // 封包完成 (4 bytes: Header, Cmd, Checksum, Footer)
        if (_bufIndex >= 4) {
            // 驗證 Footer
            if (_buffer[3] == PKT_FOOTER) {
                // 驗證 Checksum
                byte checksum = _buffer[0] ^ _buffer[1];
                if (checksum == _buffer[2]) {
                    _lastCommand = _buffer[1];
                    _hasCommand = true;
                }
            }
            _bufIndex = 0;
        }
    }

    return _hasCommand;
}

byte SerialCommand::getCommand() {
    return _lastCommand;
}
```

### 2.7 main.ino - 主程式

```cpp
// main.ino - V3 自走吸塵車
// 版本: 1.0
// 日期: 2025-12-06

#include "config.h"
#include "ultrasonic.h"
#include "behavior.h"
#include "motor.h"
#include "vacuum.h"
#include "serial_cmd.h"

// 模組實例
Ultrasonic frontUS;
Ultrasonic rightUS;
BehaviorController behavior;
Motor motor;
Vacuum vacuum;
SerialCommand serialCmd;

// 交替讀取旗標
bool readFrontNext = true;

// 感測器值
int frontDist = 100;
int rightDist = 15;

// 上次迴圈時間
unsigned long lastLoopTime = 0;

void setup() {
    // 延遲啟動 (避免 EMI)
    delay(3000);

    // 初始化模組
    frontUS.init(PIN_FRONT_TRIG, PIN_FRONT_ECHO);
    rightUS.init(PIN_RIGHT_TRIG, PIN_RIGHT_ECHO);
    behavior.init();
    motor.init();
    vacuum.init();
    serialCmd.init(115200);

    // 開啟吸塵器
    vacuum.on();

    lastLoopTime = millis();
}

void loop() {
    unsigned long currentTime = millis();

    // 維持 20Hz 迴圈
    if (currentTime - lastLoopTime < LOOP_INTERVAL) {
        return;
    }
    lastLoopTime = currentTime;

    // ===== 1. 讀取感測器 (交替) =====
    if (readFrontNext) {
        int val = frontUS.getFiltered();
        if (val > 0) frontDist = val;
    } else {
        int val = rightUS.getFiltered();
        if (val > 0) rightDist = val;
    }
    readFrontNext = !readFrontNext;

    // ===== 2. 檢查 Serial 指令 =====
    if (serialCmd.check()) {
        byte cmd = serialCmd.getCommand();
        if (cmd == CMD_VACUUM_ON) {
            vacuum.on();
        } else if (cmd == CMD_VACUUM_OFF) {
            vacuum.off();
        }
    }

    // ===== 3. 行為融合控制 =====
    MotorCommand cmd = behavior.update(frontDist, rightDist);

    // ===== 4. 輸出馬達 =====
    if (cmd.stop || behavior.isComplete()) {
        motor.stop();
        vacuum.off();
    } else {
        motor.set(cmd.leftPWM, cmd.rightPWM);
    }

    // 出場時關閉吸塵器
    if (behavior.isExiting()) {
        vacuum.off();
    }
}
```

---

## 3. Raspberry Pi 模組設計

### 3.1 目錄結構

```
v3_stable/
├── raspberry_pi/
│   ├── main.py              # 主程式
│   ├── red_detector.py      # 紅色偵測
│   ├── serial_comm.py       # 通訊模組
│   └── config.py            # 設定檔
└── arduino/
    └── main/
        ├── main.ino
        ├── config.h
        ├── ultrasonic.h/cpp
        ├── behavior.h/cpp
        ├── motor.h/cpp
        ├── vacuum.h/cpp
        └── serial_cmd.h/cpp
```

### 3.2 config.py

```python
# config.py - V3 Raspberry Pi 設定

# Serial 通訊
SERIAL_PORT = '/dev/ttyUSB0'
BAUD_RATE = 115200

# 紅色偵測
CAMERA_WIDTH = 320
CAMERA_HEIGHT = 240
CAMERA_FPS = 30
DETECTION_FPS = 10

# HSV 紅色範圍
RED_LOWER1 = (0, 100, 100)
RED_UPPER1 = (10, 255, 255)
RED_LOWER2 = (160, 100, 100)
RED_UPPER2 = (180, 255, 255)

# 偵測閾值
MIN_RED_AREA = 1000
RED_CLEAR_DELAY = 1.0  # 紅色消失後延遲 (秒)

# 指令代碼
CMD_VACUUM_ON = 0x01
CMD_VACUUM_OFF = 0x02
PKT_HEADER = 0xAA
PKT_FOOTER = 0x55
```

### 3.3 serial_comm.py

```python
# serial_comm.py - Serial 通訊模組

import serial
from config import *

class SerialComm:
    def __init__(self):
        self.ser = None

    def connect(self):
        """連接 Arduino"""
        try:
            self.ser = serial.Serial(SERIAL_PORT, BAUD_RATE, timeout=0.1)
            return True
        except Exception as e:
            print(f"Serial 連接失敗: {e}")
            return False

    def send_command(self, cmd):
        """發送指令封包"""
        if self.ser is None:
            return False

        checksum = PKT_HEADER ^ cmd
        packet = bytes([PKT_HEADER, cmd, checksum, PKT_FOOTER])

        try:
            self.ser.write(packet)
            return True
        except Exception as e:
            print(f"發送失敗: {e}")
            return False

    def vacuum_on(self):
        """開啟吸塵器"""
        return self.send_command(CMD_VACUUM_ON)

    def vacuum_off(self):
        """關閉吸塵器"""
        return self.send_command(CMD_VACUUM_OFF)

    def close(self):
        """關閉連接"""
        if self.ser:
            self.ser.close()
```

### 3.4 red_detector.py

```python
# red_detector.py - 紅色偵測模組

import cv2
import numpy as np
import threading
import time
from config import *

class RedDetector:
    def __init__(self):
        self.cap = None
        self.running = False
        self.thread = None

        self.detected = False
        self.area = 0
        self.lock = threading.Lock()

    def start(self):
        """啟動偵測"""
        self.cap = cv2.VideoCapture(0)
        self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, CAMERA_WIDTH)
        self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, CAMERA_HEIGHT)
        self.cap.set(cv2.CAP_PROP_FPS, CAMERA_FPS)

        self.running = True
        self.thread = threading.Thread(target=self._detection_loop)
        self.thread.daemon = True
        self.thread.start()

    def stop(self):
        """停止偵測"""
        self.running = False
        if self.thread:
            self.thread.join(timeout=1.0)
        if self.cap:
            self.cap.release()

    def get_status(self):
        """取得偵測狀態"""
        with self.lock:
            return self.detected, self.area

    def _detection_loop(self):
        """偵測迴圈 (背景執行緒)"""
        interval = 1.0 / DETECTION_FPS

        while self.running:
            start = time.time()

            ret, frame = self.cap.read()
            if not ret:
                continue

            # 轉換 HSV
            hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)

            # 紅色遮罩 (兩段)
            mask1 = cv2.inRange(hsv, RED_LOWER1, RED_UPPER1)
            mask2 = cv2.inRange(hsv, RED_LOWER2, RED_UPPER2)
            mask = cv2.bitwise_or(mask1, mask2)

            # 形態學處理
            kernel = np.ones((5, 5), np.uint8)
            mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)
            mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)

            # 找輪廓
            contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL,
                                           cv2.CHAIN_APPROX_SIMPLE)

            # 計算最大面積
            max_area = 0
            for cnt in contours:
                area = cv2.contourArea(cnt)
                if area > max_area:
                    max_area = area

            # 更新狀態
            with self.lock:
                self.area = max_area
                self.detected = max_area > MIN_RED_AREA

            # 維持頻率
            elapsed = time.time() - start
            if elapsed < interval:
                time.sleep(interval - elapsed)
```

### 3.5 main.py

```python
#!/usr/bin/env python3
# main.py - V3 Raspberry Pi 主程式

import time
import signal
import sys
from red_detector import RedDetector
from serial_comm import SerialComm
from config import RED_CLEAR_DELAY

class V3Controller:
    def __init__(self):
        self.detector = RedDetector()
        self.serial = SerialComm()
        self.running = False

        self.last_red_state = False
        self.red_clear_time = 0

    def start(self):
        """啟動系統"""
        print("V3 自走吸塵車 - Raspberry Pi")
        print("=" * 40)

        # 連接 Arduino
        if not self.serial.connect():
            print("無法連接 Arduino，退出")
            return
        print("Arduino 連接成功")

        # 啟動紅色偵測
        self.detector.start()
        print("紅色偵測已啟動")

        self.running = True
        self._main_loop()

    def stop(self):
        """停止系統"""
        self.running = False
        self.detector.stop()
        self.serial.close()
        print("系統已停止")

    def _main_loop(self):
        """主迴圈"""
        while self.running:
            detected, area = self.detector.get_status()

            # 紅色狀態變化處理
            if detected and not self.last_red_state:
                # 進入紅色區域 → 關閉吸塵器
                print(f"偵測到紅色 (面積: {area})")
                self.serial.vacuum_off()

            elif not detected and self.last_red_state:
                # 離開紅色區域 → 記錄時間
                self.red_clear_time = time.time()

            elif not detected and self.red_clear_time > 0:
                # 延遲後重新開啟吸塵器
                if time.time() - self.red_clear_time > RED_CLEAR_DELAY:
                    print("紅色消失，重新開啟吸塵器")
                    self.serial.vacuum_on()
                    self.red_clear_time = 0

            self.last_red_state = detected

            time.sleep(0.1)  # 10 Hz 檢查頻率

def signal_handler(sig, frame):
    """信號處理"""
    print("\n收到中斷信號")
    controller.stop()
    sys.exit(0)

if __name__ == '__main__':
    controller = V3Controller()
    signal.signal(signal.SIGINT, signal_handler)

    try:
        controller.start()
    except Exception as e:
        print(f"錯誤: {e}")
        controller.stop()
```

---

## 4. 設計決策記錄

### 4.1 為何使用雙右側超音波而非 IMU

| 考量 | IMU | 雙超音波 |
|------|-----|----------|
| 漂移問題 | 積分漂移 ~0.77°/分鐘 | 無漂移 |
| 絕對角度 | 需要校準基準 | 直接測量與牆夾角 |
| 轉彎判斷 | 需累計轉過角度 | 直接看是否平行新牆 |
| 硬體成本 | 需 I2C 連接 | 多用 2 個腳位 |
| **決策** | - | **使用雙超音波** |

### 4.2 雙超音波的優勢

1. **直接測量夾角** - 不需積分，無漂移
2. **轉彎完成判斷更可靠** - 「前方暢通 + 與新牆平行」比「轉了 90°」更實用
3. **沿牆更穩定** - 同時修正距離和角度，不會斜向撞牆
4. **簡化程式碼** - 不需處理 IMU 校準、I2C 錯誤

### 4.3 為何使用距離+角度雙 P-Control

| 考量 | 結論 |
|------|------|
| 單純距離控制 | 無法處理斜向撞牆 |
| 單純角度控制 | 無法維持目標距離 |
| 雙控制融合 | 距離和角度同時修正 |
| **決策** | **KP_DIST + KP_ANGLE 雙項控制** |

### 4.4 超音波輪流讀取策略

| 方案 | 優點 | 缺點 |
|------|------|------|
| 同時讀取 | 即時性高 | 聲波互相干擾 |
| 輪流讀取 | 無干擾 | 每個感測器更新慢 3 倍 |
| **決策** | **輪流讀取，每 50ms 讀一個** |

在 20Hz 主迴圈下：
- 每個超音波每 150ms 更新一次 (約 6.7Hz)
- 對於低速運動 (PWM 60) 足夠穩定

---

## 附錄 A：參數調校指南

### A.1 沿牆 P-Control 調參

```
現象: 震盪嚴重
→ 降低 KP_WALL (如 0.015)

現象: 反應遲緩
→ 提高 KP_WALL (如 0.025)

現象: 轉向不足
→ 提高 MAX_ANGULAR (如 0.4)
```

### A.2 馬達差異調校

```
現象: 車輛向左偏
→ 提高 LEFT_SCALE (如 1.05) 或降低 RIGHT_SCALE

現象: 車輛向右偏
→ 提高 RIGHT_SCALE (如 1.05) 或降低 LEFT_SCALE

調校方法:
1. 設 TARGET_DIST = 當前距離 (讓 angular = 0)
2. 觀察直走時的偏向
3. 微調 SCALE 直到直走穩定
```

---

## 附錄 B：修訂歷史

| 版本 | 日期 | 變更說明 |
|------|------|----------|
| 1.0 | 2025-12-06 | 初版，行為融合架構 |
| 1.1 | 2025-12-06 | 新增轉彎超時/穩定期 |
| 1.2 | 2025-12-06 | 移除視覺里程計、雙條件轉彎完成、時間窗口出場偵測 |
| 2.0 | 2025-12-07 | **重大變更**：新增右後超音波，改用距離+角度雙控制 |
