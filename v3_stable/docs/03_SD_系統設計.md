# V3 自走吸塵車 - 系統設計 (SD)

**版本**: 1.0
**日期**: 2025-12-06
**關聯文件**: 01_SRS, 02_SA

---

## 1. 設計概述

### 1.1 設計目標

基於 SA 的連續控制（行為融合）架構，本文件定義具體的軟體設計。

**核心設計原則**：
1. **Arduino 自主控制** - 所有即時控制邏輯在 Arduino 執行
2. **無狀態機** - 使用行為融合，無離散模式切換
3. **極簡通訊** - Pi 僅發送吸塵器控制指令
4. **低速穩定** - PWM 80，約 30% 動力

### 1.2 軟體架構

```
┌─────────────────────────────────────────────────────────────┐
│                      Arduino Uno                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌───────────────────────────────────────────────────────┐  │
│  │                    main.ino                           │  │
│  │  - setup()                                            │  │
│  │  - loop() [20Hz 主迴圈]                               │  │
│  └───────────────────────────────────────────────────────┘  │
│                            │                                │
│         ┌──────────────────┼──────────────────┐            │
│         ▼                  ▼                  ▼            │
│  ┌─────────────┐   ┌─────────────┐   ┌─────────────┐       │
│  │ ultrasonic  │   │ behavior    │   │ motor       │       │
│  │ .h/.cpp     │   │ .h/.cpp     │   │ .h/.cpp     │       │
│  │             │   │             │   │             │       │
│  │ - read()    │   │ - wall()    │   │ - set()     │       │
│  │ - filter()  │   │ - avoid()   │   │ - stop()    │       │
│  │             │   │ - exit()    │   │             │       │
│  │             │   │ - blend()   │   │             │       │
│  └─────────────┘   └─────────────┘   └─────────────┘       │
│                                                             │
│  ┌─────────────┐   ┌─────────────┐                         │
│  │ vacuum      │   │ serial_cmd  │                         │
│  │ .h/.cpp     │   │ .h/.cpp     │                         │
│  │             │   │             │                         │
│  │ - on()      │   │ - check()   │                         │
│  │ - off()     │   │ - parse()   │                         │
│  └─────────────┘   └─────────────┘                         │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 2. Arduino 模組設計

### 2.1 config.h - 參數定義

```cpp
#ifndef CONFIG_H
#define CONFIG_H

// ============ 腳位定義 ============
// L298N 馬達驅動
#define PIN_ENA     3   // 左輪 PWM
#define PIN_IN1     6   // 左輪方向 A
#define PIN_IN2     5   // 左輪方向 B
#define PIN_ENB     11  // 右輪 PWM
#define PIN_IN3     10  // 右輪方向 A
#define PIN_IN4     9   // 右輪方向 B

// 超聲波
#define PIN_FRONT_TRIG  7
#define PIN_FRONT_ECHO  8
#define PIN_RIGHT_TRIG  A1
#define PIN_RIGHT_ECHO  A2

// 吸塵器繼電器
#define PIN_VACUUM      A3

// ============ 控制參數 ============
// 主迴圈
#define LOOP_INTERVAL   50      // 50ms = 20Hz

// 超聲波
#define US_TIMEOUT      8000    // 8ms 超時 (~136cm)
#define US_MIN_VALID    2       // 最小有效值 cm
#define US_MAX_VALID    200     // 最大有效值 cm

// 沿牆行為
#define TARGET_DIST     15.0f   // 目標右側距離 cm
#define KP_WALL         0.02f   // 比例增益
#define MAX_ANGULAR     0.3f    // 最大轉向幅度
#define ERROR_DEADZONE  2.0f    // 誤差死區 ±2cm

// 轉彎行為
#define FRONT_STOP          20.0f   // 觸發轉彎距離 (從15提高，補償延遲)
#define FRONT_SLOW          40.0f   // 減速距離 cm
#define TURN_DETECT_DIST    30.0f   // 轉彎完成：右側新牆偵測
#define TURN_COMPLETE_FRONT 50.0f   // 轉彎完成：前方暢通
#define TURN_TIMEOUT        40      // 轉彎超時 (2秒，從3秒縮短)
#define TURN_STABLE         3       // 穩定期 (150ms)
#define TURN_FORWARD_MIN    10      // 轉彎後最小前進 (500ms)

// 出場行為
#define EXIT_THRESHOLD      50.0f   // 右側無牆距離 cm
#define EXIT_FRONT_CLEAR    60.0f   // 前方暢通距離 cm
#define EXIT_WINDOW_MIN     2000    // 出場窗口最小 ms
#define EXIT_WINDOW_MAX     15000   // 出場窗口最大 ms
#define EXIT_CONFIRM        6       // 確認計數 (300ms)
#define EXIT_TURN           22      // 右轉結束 (6+16)
#define EXIT_TOTAL          62      // 總出場 (6+16+40)

// 馬達
#define BASE_PWM        60      // 基礎 PWM (從80降低，增加反應時間)
#define TURN_PWM        60      // 原地轉彎 PWM
#define MIN_PWM         45      // 最小有效 PWM
#define LEFT_SCALE      1.0f    // 左輪比例 (調校用)
#define RIGHT_SCALE     1.0f    // 右輪比例 (調校用)

// 超時保護
#define RUN_TIMEOUT     300000  // 5 分鐘

#endif
```

### 2.2 ultrasonic.h/.cpp - 超聲波模組

```cpp
// ultrasonic.h
#ifndef ULTRASONIC_H
#define ULTRASONIC_H

class Ultrasonic {
public:
    void init(int trigPin, int echoPin);
    int read();              // 讀取距離 (cm)
    int getFiltered();       // 取得濾波後距離

private:
    int _trigPin, _echoPin;
    int _history[3];         // 中值濾波歷史
    int _histIndex;
    int _filter(int value);
};

#endif
```

```cpp
// ultrasonic.cpp
#include "ultrasonic.h"
#include "config.h"
#include <Arduino.h>

void Ultrasonic::init(int trigPin, int echoPin) {
    _trigPin = trigPin;
    _echoPin = echoPin;
    pinMode(_trigPin, OUTPUT);
    pinMode(_echoPin, INPUT);

    // 初始化歷史為目標距離
    for (int i = 0; i < 3; i++) {
        _history[i] = TARGET_DIST;
    }
    _histIndex = 0;
}

int Ultrasonic::read() {
    // 發送觸發脈衝
    digitalWrite(_trigPin, LOW);
    delayMicroseconds(2);
    digitalWrite(_trigPin, HIGH);
    delayMicroseconds(10);
    digitalWrite(_trigPin, LOW);

    // 讀取回波時間
    long duration = pulseIn(_echoPin, HIGH, US_TIMEOUT);

    // 轉換為距離 (cm)
    if (duration == 0) {
        return -1;  // 超時
    }
    int dist = duration / 58;

    // 有效性檢查
    if (dist < US_MIN_VALID || dist > US_MAX_VALID) {
        return -1;
    }

    return dist;
}

int Ultrasonic::getFiltered() {
    int raw = read();
    return _filter(raw);
}

int Ultrasonic::_filter(int value) {
    // 只接受有效值
    if (value > 0) {
        _history[_histIndex] = value;
        _histIndex = (_histIndex + 1) % 3;
    }

    // 中值濾波
    int a = _history[0];
    int b = _history[1];
    int c = _history[2];

    if (a > b) { int t = a; a = b; b = t; }
    if (b > c) { int t = b; b = c; c = t; }
    if (a > b) { int t = a; a = b; b = t; }

    return b;  // 中位數
}
```

### 2.3 behavior.h/.cpp - 優先級覆蓋控制模組

```cpp
// behavior.h
#ifndef BEHAVIOR_H
#define BEHAVIOR_H

#include <avr/wdt.h>  // Watchdog

struct MotorCommand {
    int leftPWM;        // -255 ~ +255
    int rightPWM;       // -255 ~ +255
    bool stop;          // 是否停止
};

class BehaviorController {
public:
    void init();
    MotorCommand update(int frontDist, int rightDist);

    int getCornerCount() { return _cornerCount; }
    bool isTurning() { return _isTurning; }
    bool isExiting() { return _exitCounter >= EXIT_CONFIRM; }
    bool isComplete() { return _complete; }

private:
    // 優先級控制
    MotorCommand _handleTurning(int frontDist, int rightDist);
    MotorCommand _handleExit(int frontDist, int rightDist);
    MotorCommand _handleWallFollow(int frontDist, int rightDist);
    void _updateExitCounter(int frontDist, int rightDist);

    // 狀態變數
    int _cornerCount;
    bool _isTurning;
    int _turnConfirm;
    int _turnTimer;         // 轉彎計時 (超時保護)
    int _stableTimer;       // 穩定期計時 (轉彎後直行)
    float _exitCounter;     // float 支援緩慢衰減
    bool _complete;
    unsigned long _startTime;
    unsigned long _exitSearchStart;  // 出場搜尋開始時間 (第4角後)
};

#endif
```

```cpp
// behavior.cpp - 優先級覆蓋控制
#include "behavior.h"
#include "config.h"
#include <Arduino.h>

void BehaviorController::init() {
    _cornerCount = 0;
    _isTurning = false;
    _turnConfirm = 0;
    _turnTimer = 0;
    _stableTimer = 0;
    _exitCounter = 0;
    _complete = false;
    _startTime = millis();
    _exitSearchStart = 0;  // 出場搜尋尚未開始

    // 啟用 Watchdog (2 秒)
    wdt_enable(WDTO_2S);
}

MotorCommand BehaviorController::update(int frontDist, int rightDist) {
    // 餵狗
    wdt_reset();

    // 超時保護
    if (millis() - _startTime > RUN_TIMEOUT) {
        _complete = true;
        return {0, 0, true};
    }

    // 已完成
    if (_complete) {
        return {0, 0, true};
    }

    // ===== 穩定期：剛轉完彎，維持沿牆 =====
    if (_stableTimer > 0) {
        _stableTimer--;
        return _handleWallFollow(frontDist, rightDist);
    }

    // ===== 優先級 1: 原地轉彎 =====
    if (_isTurning || frontDist < FRONT_STOP) {
        return _handleTurning(frontDist, rightDist);
    }

    // ===== 優先級 2: 出場 =====
    _updateExitCounter(frontDist, rightDist);
    if (_exitCounter >= EXIT_CONFIRM) {
        return _handleExit(frontDist, rightDist);
    }

    // ===== 優先級 3: 沿牆 + 減速避障 =====
    return _handleWallFollow(frontDist, rightDist);
}

// ===== 優先級 1: 原地轉彎 =====
MotorCommand BehaviorController::_handleTurning(int frontDist, int rightDist) {
    // 首次進入轉彎
    if (!_isTurning) {
        _isTurning = true;
        _turnTimer = 0;
        _turnConfirm = 0;
    }

    // 轉彎計時 (超時保護)
    _turnTimer++;
    if (_turnTimer > TURN_TIMEOUT) {
        // 超時強制結束轉彎，視為完成一角
        _isTurning = false;
        _turnTimer = 0;
        _turnConfirm = 0;
        _stableTimer = TURN_STABLE + TURN_FORWARD_MIN;  // 延長穩定期
        _cornerCount++;
        // 第 4 角完成後開始出場搜尋窗口
        if (_cornerCount == 4) {
            _exitSearchStart = millis();
        }
        return _handleWallFollow(frontDist, rightDist);
    }

    // 雙條件檢查轉彎完成：
    // 條件 A: 右側看到新牆 (<30cm)
    // 條件 B: 前方暢通 (>50cm，表示已離開角落)
    bool rightWallDetected = (rightDist < TURN_DETECT_DIST && rightDist > 5);
    bool frontCleared = (frontDist > TURN_COMPLETE_FRONT);

    if (rightWallDetected || frontCleared) {
        _turnConfirm++;
    } else {
        _turnConfirm = 0;
    }

    // 連續 3 次確認 (150ms) 表示轉彎完成
    if (_turnConfirm >= 3) {
        _isTurning = false;
        _turnTimer = 0;
        _turnConfirm = 0;
        _stableTimer = TURN_STABLE + TURN_FORWARD_MIN;  // 延長穩定期
        _cornerCount++;
        // 第 4 角完成後開始出場搜尋窗口
        if (_cornerCount == 4) {
            _exitSearchStart = millis();
        }
        return _handleWallFollow(frontDist, rightDist);
    }

    // 原地左轉
    return {-TURN_PWM, +TURN_PWM, false};
}

// ===== 優先級 2: 出場 =====
void BehaviorController::_updateExitCounter(int frontDist, int rightDist) {
    // 時間窗口檢查：第 4 角後 2~15 秒內才搜尋出口
    unsigned long now = millis();
    bool inExitWindow = (_exitSearchStart > 0) &&
                        (now - _exitSearchStart >= EXIT_WINDOW_MIN) &&
                        (now - _exitSearchStart <= EXIT_WINDOW_MAX);

    // 多條件確認
    bool exitCondition =
        _cornerCount >= 4 &&
        inExitWindow &&                       // 在有效時間窗口內
        rightDist > EXIT_THRESHOLD &&         // 右側無牆 (>50cm)
        frontDist > EXIT_FRONT_CLEAR &&       // 前方暢通 (>60cm)
        _stableTimer == 0 &&                  // 不在穩定期
        !_isTurning;

    if (exitCondition) {
        _exitCounter += 1.0f;
    } else if (_exitCounter > 0 && _exitCounter < EXIT_CONFIRM) {
        // 容許短暫中斷，緩慢衰減
        _exitCounter -= 0.5f;
        if (_exitCounter < 0) _exitCounter = 0;
    } else {
        _exitCounter = 0;
    }
}

MotorCommand BehaviorController::_handleExit(int frontDist, int rightDist) {
    // 階段 1: 右轉朝向出口
    if (_exitCounter < EXIT_TURN) {
        return {+TURN_PWM, -TURN_PWM/2, false};
    }

    // 階段 2: 直走出場
    if (_exitCounter < EXIT_TOTAL) {
        _exitCounter += 1.0f;
        return {BASE_PWM, BASE_PWM, false};
    }

    // 階段 3: 停止
    _complete = true;
    return {0, 0, true};
}

// ===== 優先級 3: 沿牆 + 減速避障 =====
MotorCommand BehaviorController::_handleWallFollow(int frontDist, int rightDist) {
    // 沿牆行為
    float error = TARGET_DIST - rightDist;
    float angular_wall = KP_WALL * error;
    if (angular_wall > MAX_ANGULAR) angular_wall = MAX_ANGULAR;
    if (angular_wall < -MAX_ANGULAR) angular_wall = -MAX_ANGULAR;

    // 減速避障（僅在 15-40cm 區間融合）
    float avoid_weight = 0;
    float angular_avoid = 0;
    if (frontDist >= FRONT_STOP && frontDist < FRONT_SLOW) {
        avoid_weight = (float)(FRONT_SLOW - frontDist) / (FRONT_SLOW - FRONT_STOP);
        if (avoid_weight > 0.8f) avoid_weight = 0.8f;
        angular_avoid = 0.3f;
    }

    // 加權融合
    float wall_weight = 1.0f - avoid_weight;
    float angular = wall_weight * angular_wall + avoid_weight * angular_avoid;

    // 轉換為 PWM
    int leftPWM = (int)(BASE_PWM * (1.0f - angular));
    int rightPWM = (int)(BASE_PWM * (1.0f + angular));

    // 應用馬達比例校正
    leftPWM = (int)(leftPWM * LEFT_SCALE);
    rightPWM = (int)(rightPWM * RIGHT_SCALE);

    // 限幅
    if (leftPWM > 0 && leftPWM < MIN_PWM) leftPWM = MIN_PWM;
    if (rightPWM > 0 && rightPWM < MIN_PWM) rightPWM = MIN_PWM;
    if (leftPWM > 255) leftPWM = 255;
    if (rightPWM > 255) rightPWM = 255;

    return {leftPWM, rightPWM, false};
}
```

### 2.4 motor.h/.cpp - 馬達驅動模組

```cpp
// motor.h
#ifndef MOTOR_H
#define MOTOR_H

class Motor {
public:
    void init();
    void set(int leftPWM, int rightPWM);
    void stop();

private:
    void _setLeft(int pwm);
    void _setRight(int pwm);
};

#endif
```

```cpp
// motor.cpp
#include "motor.h"
#include "config.h"
#include <Arduino.h>

void Motor::init() {
    pinMode(PIN_ENA, OUTPUT);
    pinMode(PIN_IN1, OUTPUT);
    pinMode(PIN_IN2, OUTPUT);
    pinMode(PIN_ENB, OUTPUT);
    pinMode(PIN_IN3, OUTPUT);
    pinMode(PIN_IN4, OUTPUT);

    stop();
}

void Motor::set(int leftPWM, int rightPWM) {
    _setLeft(leftPWM);
    _setRight(rightPWM);
}

void Motor::stop() {
    analogWrite(PIN_ENA, 0);
    analogWrite(PIN_ENB, 0);
    digitalWrite(PIN_IN1, LOW);
    digitalWrite(PIN_IN2, LOW);
    digitalWrite(PIN_IN3, LOW);
    digitalWrite(PIN_IN4, LOW);
}

void Motor::_setLeft(int pwm) {
    if (pwm > 0) {
        // 前進
        digitalWrite(PIN_IN1, HIGH);
        digitalWrite(PIN_IN2, LOW);
        analogWrite(PIN_ENA, pwm);
    } else if (pwm < 0) {
        // 後退
        digitalWrite(PIN_IN1, LOW);
        digitalWrite(PIN_IN2, HIGH);
        analogWrite(PIN_ENA, -pwm);
    } else {
        // 停止
        digitalWrite(PIN_IN1, LOW);
        digitalWrite(PIN_IN2, LOW);
        analogWrite(PIN_ENA, 0);
    }
}

void Motor::_setRight(int pwm) {
    if (pwm > 0) {
        // 前進
        digitalWrite(PIN_IN3, HIGH);
        digitalWrite(PIN_IN4, LOW);
        analogWrite(PIN_ENB, pwm);
    } else if (pwm < 0) {
        // 後退
        digitalWrite(PIN_IN3, LOW);
        digitalWrite(PIN_IN4, HIGH);
        analogWrite(PIN_ENB, -pwm);
    } else {
        // 停止
        digitalWrite(PIN_IN3, LOW);
        digitalWrite(PIN_IN4, LOW);
        analogWrite(PIN_ENB, 0);
    }
}
```

### 2.5 vacuum.h/.cpp - 吸塵器模組

```cpp
// vacuum.h
#ifndef VACUUM_H
#define VACUUM_H

class Vacuum {
public:
    void init();
    void on();
    void off();
    bool isOn() { return _isOn; }

private:
    bool _isOn;
};

#endif
```

```cpp
// vacuum.cpp
#include "vacuum.h"
#include "config.h"
#include <Arduino.h>

void Vacuum::init() {
    pinMode(PIN_VACUUM, OUTPUT);
    off();
}

void Vacuum::on() {
    digitalWrite(PIN_VACUUM, HIGH);
    _isOn = true;
}

void Vacuum::off() {
    digitalWrite(PIN_VACUUM, LOW);
    _isOn = false;
}
```

### 2.6 serial_cmd.h/.cpp - 指令處理模組

```cpp
// serial_cmd.h
#ifndef SERIAL_CMD_H
#define SERIAL_CMD_H

// 指令定義
#define CMD_VACUUM_ON   0x01
#define CMD_VACUUM_OFF  0x02

// 封包格式
#define PKT_HEADER      0xAA
#define PKT_FOOTER      0x55

class SerialCommand {
public:
    void init(long baudRate);
    bool check();           // 檢查是否有新指令
    byte getCommand();      // 取得指令

private:
    byte _buffer[4];
    int _bufIndex;
    byte _lastCommand;
    bool _hasCommand;
};

#endif
```

```cpp
// serial_cmd.cpp
#include "serial_cmd.h"
#include <Arduino.h>

void SerialCommand::init(long baudRate) {
    Serial.begin(baudRate);
    _bufIndex = 0;
    _lastCommand = 0;
    _hasCommand = false;
}

bool SerialCommand::check() {
    _hasCommand = false;

    while (Serial.available()) {
        byte b = Serial.read();

        // 尋找封包頭
        if (_bufIndex == 0) {
            if (b == PKT_HEADER) {
                _buffer[_bufIndex++] = b;
            }
            continue;
        }

        _buffer[_bufIndex++] = b;

        // 封包完成 (4 bytes: Header, Cmd, Checksum, Footer)
        if (_bufIndex >= 4) {
            // 驗證 Footer
            if (_buffer[3] == PKT_FOOTER) {
                // 驗證 Checksum
                byte checksum = _buffer[0] ^ _buffer[1];
                if (checksum == _buffer[2]) {
                    _lastCommand = _buffer[1];
                    _hasCommand = true;
                }
            }
            _bufIndex = 0;
        }
    }

    return _hasCommand;
}

byte SerialCommand::getCommand() {
    return _lastCommand;
}
```

### 2.7 main.ino - 主程式

```cpp
// main.ino - V3 自走吸塵車
// 版本: 1.0
// 日期: 2025-12-06

#include "config.h"
#include "ultrasonic.h"
#include "behavior.h"
#include "motor.h"
#include "vacuum.h"
#include "serial_cmd.h"

// 模組實例
Ultrasonic frontUS;
Ultrasonic rightUS;
BehaviorController behavior;
Motor motor;
Vacuum vacuum;
SerialCommand serialCmd;

// 交替讀取旗標
bool readFrontNext = true;

// 感測器值
int frontDist = 100;
int rightDist = 15;

// 上次迴圈時間
unsigned long lastLoopTime = 0;

void setup() {
    // 延遲啟動 (避免 EMI)
    delay(3000);

    // 初始化模組
    frontUS.init(PIN_FRONT_TRIG, PIN_FRONT_ECHO);
    rightUS.init(PIN_RIGHT_TRIG, PIN_RIGHT_ECHO);
    behavior.init();
    motor.init();
    vacuum.init();
    serialCmd.init(115200);

    // 開啟吸塵器
    vacuum.on();

    lastLoopTime = millis();
}

void loop() {
    unsigned long currentTime = millis();

    // 維持 20Hz 迴圈
    if (currentTime - lastLoopTime < LOOP_INTERVAL) {
        return;
    }
    lastLoopTime = currentTime;

    // ===== 1. 讀取感測器 (交替) =====
    if (readFrontNext) {
        int val = frontUS.getFiltered();
        if (val > 0) frontDist = val;
    } else {
        int val = rightUS.getFiltered();
        if (val > 0) rightDist = val;
    }
    readFrontNext = !readFrontNext;

    // ===== 2. 檢查 Serial 指令 =====
    if (serialCmd.check()) {
        byte cmd = serialCmd.getCommand();
        if (cmd == CMD_VACUUM_ON) {
            vacuum.on();
        } else if (cmd == CMD_VACUUM_OFF) {
            vacuum.off();
        }
    }

    // ===== 3. 行為融合控制 =====
    MotorCommand cmd = behavior.update(frontDist, rightDist);

    // ===== 4. 輸出馬達 =====
    if (cmd.stop || behavior.isComplete()) {
        motor.stop();
        vacuum.off();
    } else {
        motor.set(cmd.leftPWM, cmd.rightPWM);
    }

    // 出場時關閉吸塵器
    if (behavior.isExiting()) {
        vacuum.off();
    }
}
```

---

## 3. Raspberry Pi 模組設計

### 3.1 目錄結構

```
v3_stable/
├── raspberry_pi/
│   ├── main.py              # 主程式
│   ├── red_detector.py      # 紅色偵測
│   ├── serial_comm.py       # 通訊模組
│   └── config.py            # 設定檔
└── arduino/
    └── main/
        ├── main.ino
        ├── config.h
        ├── ultrasonic.h/cpp
        ├── behavior.h/cpp
        ├── motor.h/cpp
        ├── vacuum.h/cpp
        └── serial_cmd.h/cpp
```

### 3.2 config.py

```python
# config.py - V3 Raspberry Pi 設定

# Serial 通訊
SERIAL_PORT = '/dev/ttyUSB0'
BAUD_RATE = 115200

# 紅色偵測
CAMERA_WIDTH = 320
CAMERA_HEIGHT = 240
CAMERA_FPS = 30
DETECTION_FPS = 10

# HSV 紅色範圍
RED_LOWER1 = (0, 100, 100)
RED_UPPER1 = (10, 255, 255)
RED_LOWER2 = (160, 100, 100)
RED_UPPER2 = (180, 255, 255)

# 偵測閾值
MIN_RED_AREA = 1000
RED_CLEAR_DELAY = 1.0  # 紅色消失後延遲 (秒)

# 指令代碼
CMD_VACUUM_ON = 0x01
CMD_VACUUM_OFF = 0x02
PKT_HEADER = 0xAA
PKT_FOOTER = 0x55
```

### 3.3 serial_comm.py

```python
# serial_comm.py - Serial 通訊模組

import serial
from config import *

class SerialComm:
    def __init__(self):
        self.ser = None

    def connect(self):
        """連接 Arduino"""
        try:
            self.ser = serial.Serial(SERIAL_PORT, BAUD_RATE, timeout=0.1)
            return True
        except Exception as e:
            print(f"Serial 連接失敗: {e}")
            return False

    def send_command(self, cmd):
        """發送指令封包"""
        if self.ser is None:
            return False

        checksum = PKT_HEADER ^ cmd
        packet = bytes([PKT_HEADER, cmd, checksum, PKT_FOOTER])

        try:
            self.ser.write(packet)
            return True
        except Exception as e:
            print(f"發送失敗: {e}")
            return False

    def vacuum_on(self):
        """開啟吸塵器"""
        return self.send_command(CMD_VACUUM_ON)

    def vacuum_off(self):
        """關閉吸塵器"""
        return self.send_command(CMD_VACUUM_OFF)

    def close(self):
        """關閉連接"""
        if self.ser:
            self.ser.close()
```

### 3.4 red_detector.py

```python
# red_detector.py - 紅色偵測模組

import cv2
import numpy as np
import threading
import time
from config import *

class RedDetector:
    def __init__(self):
        self.cap = None
        self.running = False
        self.thread = None

        self.detected = False
        self.area = 0
        self.lock = threading.Lock()

    def start(self):
        """啟動偵測"""
        self.cap = cv2.VideoCapture(0)
        self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, CAMERA_WIDTH)
        self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, CAMERA_HEIGHT)
        self.cap.set(cv2.CAP_PROP_FPS, CAMERA_FPS)

        self.running = True
        self.thread = threading.Thread(target=self._detection_loop)
        self.thread.daemon = True
        self.thread.start()

    def stop(self):
        """停止偵測"""
        self.running = False
        if self.thread:
            self.thread.join(timeout=1.0)
        if self.cap:
            self.cap.release()

    def get_status(self):
        """取得偵測狀態"""
        with self.lock:
            return self.detected, self.area

    def _detection_loop(self):
        """偵測迴圈 (背景執行緒)"""
        interval = 1.0 / DETECTION_FPS

        while self.running:
            start = time.time()

            ret, frame = self.cap.read()
            if not ret:
                continue

            # 轉換 HSV
            hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)

            # 紅色遮罩 (兩段)
            mask1 = cv2.inRange(hsv, RED_LOWER1, RED_UPPER1)
            mask2 = cv2.inRange(hsv, RED_LOWER2, RED_UPPER2)
            mask = cv2.bitwise_or(mask1, mask2)

            # 形態學處理
            kernel = np.ones((5, 5), np.uint8)
            mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)
            mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)

            # 找輪廓
            contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL,
                                           cv2.CHAIN_APPROX_SIMPLE)

            # 計算最大面積
            max_area = 0
            for cnt in contours:
                area = cv2.contourArea(cnt)
                if area > max_area:
                    max_area = area

            # 更新狀態
            with self.lock:
                self.area = max_area
                self.detected = max_area > MIN_RED_AREA

            # 維持頻率
            elapsed = time.time() - start
            if elapsed < interval:
                time.sleep(interval - elapsed)
```

### 3.5 main.py

```python
#!/usr/bin/env python3
# main.py - V3 Raspberry Pi 主程式

import time
import signal
import sys
from red_detector import RedDetector
from serial_comm import SerialComm
from config import RED_CLEAR_DELAY

class V3Controller:
    def __init__(self):
        self.detector = RedDetector()
        self.serial = SerialComm()
        self.running = False

        self.last_red_state = False
        self.red_clear_time = 0

    def start(self):
        """啟動系統"""
        print("V3 自走吸塵車 - Raspberry Pi")
        print("=" * 40)

        # 連接 Arduino
        if not self.serial.connect():
            print("無法連接 Arduino，退出")
            return
        print("Arduino 連接成功")

        # 啟動紅色偵測
        self.detector.start()
        print("紅色偵測已啟動")

        self.running = True
        self._main_loop()

    def stop(self):
        """停止系統"""
        self.running = False
        self.detector.stop()
        self.serial.close()
        print("系統已停止")

    def _main_loop(self):
        """主迴圈"""
        while self.running:
            detected, area = self.detector.get_status()

            # 紅色狀態變化處理
            if detected and not self.last_red_state:
                # 進入紅色區域 → 關閉吸塵器
                print(f"偵測到紅色 (面積: {area})")
                self.serial.vacuum_off()

            elif not detected and self.last_red_state:
                # 離開紅色區域 → 記錄時間
                self.red_clear_time = time.time()

            elif not detected and self.red_clear_time > 0:
                # 延遲後重新開啟吸塵器
                if time.time() - self.red_clear_time > RED_CLEAR_DELAY:
                    print("紅色消失，重新開啟吸塵器")
                    self.serial.vacuum_on()
                    self.red_clear_time = 0

            self.last_red_state = detected

            time.sleep(0.1)  # 10 Hz 檢查頻率

def signal_handler(sig, frame):
    """信號處理"""
    print("\n收到中斷信號")
    controller.stop()
    sys.exit(0)

if __name__ == '__main__':
    controller = V3Controller()
    signal.signal(signal.SIGINT, signal_handler)

    try:
        controller.start()
    except Exception as e:
        print(f"錯誤: {e}")
        controller.stop()
```

---

## 4. 設計決策記錄

### 4.1 為何不使用 IMU

| 考量 | 結論 |
|------|------|
| 漂移問題 | MPU6050 積分漂移 ~0.77°/分鐘 |
| I2C 複雜度 | 增加程式碼和故障點 |
| 必要性 | 開環轉彎 + 沿牆修正已足夠 |
| **決策** | **V3 不使用 IMU** |

### 4.2 為何使用 P-Control 而非 PID

| 考量 | 結論 |
|------|------|
| I 項問題 | 超聲波讀值跳動導致積分飽和 |
| D 項問題 | 雜訊放大 |
| 低速場景 | P-Control 已足夠平滑 |
| **決策** | **純 P-Control + 限幅** |

### 4.3 為何極簡通訊協定

| 考量 | 結論 |
|------|------|
| V2 問題 | 複雜協定增加解析負擔 |
| 必要性 | Arduino 自主控制，Pi 只需控制吸塵器 |
| 可靠性 | 封包越短，錯誤機率越低 |
| **決策** | **4 byte 封包，僅吸塵器控制** |

---

## 附錄 A：參數調校指南

### A.1 沿牆 P-Control 調參

```
現象: 震盪嚴重
→ 降低 KP_WALL (如 0.015)

現象: 反應遲緩
→ 提高 KP_WALL (如 0.025)

現象: 轉向不足
→ 提高 MAX_ANGULAR (如 0.4)
```

### A.2 馬達差異調校

```
現象: 車輛向左偏
→ 提高 LEFT_SCALE (如 1.05) 或降低 RIGHT_SCALE

現象: 車輛向右偏
→ 提高 RIGHT_SCALE (如 1.05) 或降低 LEFT_SCALE

調校方法:
1. 設 TARGET_DIST = 當前距離 (讓 angular = 0)
2. 觀察直走時的偏向
3. 微調 SCALE 直到直走穩定
```

---

## 附錄 B：修訂歷史

| 版本 | 日期 | 變更說明 |
|------|------|----------|
| 1.0 | 2025-12-06 | 初版，行為融合架構 |
| 1.1 | 2025-12-06 | 新增轉彎超時/穩定期 |
| 1.2 | 2025-12-06 | 移除視覺里程計、雙條件轉彎完成、時間窗口出場偵測 |
