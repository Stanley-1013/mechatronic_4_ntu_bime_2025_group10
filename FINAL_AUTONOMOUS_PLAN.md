# æœŸæœ«è‡ªèµ°ç«¶è³½ç³»çµ±è¨­è¨ˆæ–¹æ¡ˆ

**æ›´æ–°æ—¥æœŸï¼š** 2025-11-25
**ç«¶è³½ç›®æ¨™ï¼š** è¨ˆæ™‚æ¸…æƒç´™å±‘ä¸¦é›¢å ´
**è©•åˆ†æ¨™æº–ï¼š** æ™‚é–“ç´šè·åˆ†æ•¸ + ç´™å±‘æ•¸é‡åˆ†æ•¸
**ç¡¬é«”é™åˆ¶ï¼š** ç„¡ç·¨ç¢¼å™¨ã€ç„¡é å¸ƒç½®æ¨™è¨˜

---

## æ ¸å¿ƒè¨­è¨ˆç†å¿µï¼šä¸‰å±¤èåˆæ¶æ§‹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    æ··åˆå°èˆªç³»çµ±                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Layer 1: å®‰å…¨å±¤ï¼ˆæœ€é«˜å„ªå…ˆï¼Œå¹³é †ä¿®æ­£ï¼‰                       â”‚
â”‚  â”œâ”€ è¶…è²æ³¢å³æ™‚æ¸¬è· â†’ å¹³æ»‘æ¸›é€Ÿ + è½‰å‘ä¿®æ­£ï¼ˆä¸æ€¥åœï¼‰          â”‚
â”‚  â””â”€ è¦–è¦ºç´…è‰²åµæ¸¬ â†’ å¹³é †ç¹é–‹ï¼ˆä¸æ˜¯ã€Œåš‡åˆ°ã€çš„ç·Šæ€¥è¿´é¿ï¼‰       â”‚
â”‚      ğŸ’¡ çœ‹åˆ°ç´…è‰² = ã€Œé€™é‚Šä¸è¦å»ã€ï¼Œå¹³é †è½‰å‘è€Œéæ€¥ç…         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Layer 2: ç›¸å°å®šä½å±¤ï¼ˆMPU6050ï¼‰                              â”‚
â”‚  â”œâ”€ èˆªå‘è§’è¿½è¹¤ â†’ çŸ¥é“ã€Œé¢å‘å“ªè£¡ã€                           â”‚
â”‚  â”œâ”€ è½‰å½è§’åº¦ç´¯è¨ˆ â†’ çŸ¥é“ã€Œè½‰äº†å¤šå°‘ã€                         â”‚
â”‚  â””â”€ é…åˆé è¼‰åœ°åœ– â†’ ç²—ç•¥çŸ¥é“ã€Œåœ¨å“ªå€‹å€åŸŸã€                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Layer 3: é è¼‰å€åŸŸè³‡è¨Šï¼ˆæ¸›è¼•è¦–è¦ºå£“åŠ›ï¼‰                       â”‚
â”‚  â”œâ”€ ç´™å±‘å€åŸŸä½ç½®ï¼ˆæå‰è¼¸å…¥ 4 è§’è½ + 1 ä¸­å¤®ï¼‰                â”‚
â”‚  â”œâ”€ å…¥å£æ–¹å‘è¨˜éŒ„                                            â”‚
â”‚  â””â”€ å ´åœ°å¤§å°ä¼°è¨ˆ                                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Layer 4: è¦–è¦ºç¢ºèªå±¤ï¼ˆè¼”åŠ©è€Œéä¸»å°ï¼‰                         â”‚
â”‚  â”œâ”€ ç´…è‰²è† å¸¶åµæ¸¬ â†’ ç¢ºèªç¦å€ï¼Œå¹³é †é¿é–‹                       â”‚
â”‚  â”œâ”€ ç´™å±‘åµæ¸¬ â†’ å€åŸŸå…§ç²¾ç¢ºæ¸…æƒ                               â”‚
â”‚  â””â”€ é»‘è‰²è† å¸¶åµæ¸¬ â†’ ç¢ºèªåˆ°é”ç›®æ¨™å€ï¼ˆå¯é¸ï¼‰                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**è¨­è¨ˆå“²å­¸ï¼šå…ˆæ±‚ç©©**
- å®‰å…¨å±¤ = å¹³é †ä¿®æ­£ï¼Œä¸æ˜¯ã€Œè¢«åš‡åˆ°ã€çš„æ€¥ç…
- ç”¨ IMU æä¾›ç²—ç•¥ä½ç½®æ„ŸçŸ¥ â†’ æ¸›å°‘è¦–è¦ºä¾è³´
- é è¼‰å€åŸŸè³‡è¨Š â†’ æ©Ÿå™¨äººã€ŒçŸ¥é“ã€ç´™å±‘åœ¨å“ªï¼Œåªéœ€ç¢ºèª
- è¦–è¦ºé™ç´šç‚ºã€Œç¢ºèªã€è€Œéã€Œç™¼ç¾ã€ â†’ é™ä½ç›¸æ©Ÿå“è³ªå½±éŸ¿

### æ„Ÿæ¸¬å™¨é…ç½®

```
            [ç›¸æ©Ÿ]
         å‰æ–¹è¦–é‡
         é»‘ç‰†/ç´…è‰²/ç´™å±‘
              â†“
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚               â”‚
    â†â”€â”€â”€â”¤   [æ©Ÿå™¨äºº]    â”œâ”€â”€â”€â†’
   å·¦è¶…è²æ³¢            å³è¶…è²æ³¢
   (å·¦å´ç‰†)            (å³å´ç‰†)
        â”‚               â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

| æ„Ÿæ¸¬å™¨ | ç”¨é€” | å„ªå…ˆç´š |
|--------|------|--------|
| **å·¦è¶…è²æ³¢** | å·¦å´ç‰†è·ï¼Œæ–œå‘ç§»å‹•ä¿è­· | é«˜ |
| **å³è¶…è²æ³¢** | å³å´ç‰†è·ï¼Œæ–œå‘ç§»å‹•ä¿è­· | é«˜ |
| **ç›¸æ©Ÿ-é»‘è‰²** | å‰æ–¹é»‘ç‰†åµæ¸¬ï¼ˆç°¡å–®åˆ¤æ–·ï¼‰ | ä¸­ |
| **ç›¸æ©Ÿ-ç´…è‰²** | ç´…è‰²ç¦å€åµæ¸¬ | é«˜ |
| **ç›¸æ©Ÿ-ç™½è‰²** | ç´™å±‘åµæ¸¬ | æ¸…æƒæ™‚ |
| **ç›¸æ©Ÿ-é»‘è† å¸¶** | ç¢ºèªåˆ°é”å€åŸŸï¼ˆoptionalï¼‰ | ä½ |
| **MPU6050** | èˆªå‘è¿½è¹¤ | å°èˆªæ™‚ |

---

## é›¶ã€æ··åˆæ¶æ§‹æ ¸å¿ƒæ¨¡çµ„

### 0.1 é è¼‰å€åŸŸåœ°åœ–ï¼ˆç´…å€éš¨æ©Ÿç‰ˆï¼‰

```python
import numpy as np
import cv2

class PreloadedFieldMap:
    """
    é è¼‰å ´åœ°è³‡è¨Š - æ¸›è¼•è¦–è¦ºå£“åŠ›çš„é—œéµ

    å ´åœ°ä½ˆå±€ï¼š
         å…¥å£
          â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ [C1]       [C2] â”‚   C1-C4: å››è§’è½ï¼ˆå…¶ä¸­ 3 å€‹æœ‰ç´™å±‘ï¼Œ1 å€‹æ˜¯ç´…å€ï¼‰
    â”‚   â•²         â•±   â”‚   Z5: ä¸­å¤®ç´™å±‘å€
    â”‚     â•²     â•±     â”‚
    â”‚       [Z5]      â”‚   âš ï¸ ç´…å€ä½ç½®éš¨æ©Ÿï¼Œéœ€è¦–è¦ºç¢ºèªï¼
    â”‚     â•±     â•²     â”‚
    â”‚   â•±         â•²   â”‚
    â”‚ [C3]       [C4] â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    ç­–ç•¥ï¼š
    - é è¼‰ 4 å€‹è§’è½ + 1 ä¸­å¤®çš„ã€Œä½ç½®ã€
    - åˆ°é”è§’è½å‰ï¼Œç”¨è¦–è¦ºç¢ºèªæ˜¯ç´…å€é‚„æ˜¯ç´™å±‘å€
    - ç´…å€ â†’ è·³éï¼Œç´™å±‘å€ â†’ æ¸…æƒ
    """

    def __init__(self, field_size=2.0):
        self.field_size = field_size
        self.half = field_size / 2

        # 4 å€‹è§’è½ä½ç½®ï¼ˆé‚„ä¸çŸ¥é“å“ªå€‹æ˜¯ç´…å€ï¼‰
        # æ ¼å¼: (angle_from_entry, distance_from_entry)
        self.corners = {
            'C1': {'angle': -45, 'distance': 1.4, 'status': 'unknown'},   # å·¦å‰è§’
            'C2': {'angle': 45, 'distance': 1.4, 'status': 'unknown'},    # å³å‰è§’
            'C3': {'angle': -135, 'distance': 1.4, 'status': 'unknown'},  # å·¦å¾Œè§’
            'C4': {'angle': 135, 'distance': 1.4, 'status': 'unknown'},   # å³å¾Œè§’
        }

        # ä¸­å¤®å€åŸŸï¼ˆä¸€å®šæ˜¯ç´™å±‘å€ï¼Œä½åˆ†ï¼‰
        self.center = {
            'Z5': {'angle': 0, 'distance': 1.0, 'status': 'paper', 'priority': 3}
        }

        # å…¥å£è³‡è¨Š
        self.entry_heading = 0

    def mark_corner_as_red(self, corner_id):
        """è¦–è¦ºç¢ºèªå¾Œï¼Œæ¨™è¨˜æŸè§’è½ç‚ºç´…å€"""
        if corner_id in self.corners:
            self.corners[corner_id]['status'] = 'red'
            print(f"[åœ°åœ–] {corner_id} æ¨™è¨˜ç‚ºç´…å€")

    def mark_corner_as_paper(self, corner_id):
        """è¦–è¦ºç¢ºèªå¾Œï¼Œæ¨™è¨˜æŸè§’è½ç‚ºç´™å±‘å€"""
        if corner_id in self.corners:
            self.corners[corner_id]['status'] = 'paper'
            print(f"[åœ°åœ–] {corner_id} æ¨™è¨˜ç‚ºç´™å±‘å€")

    def mark_corner_cleaned(self, corner_id):
        """æ¨™è¨˜è§’è½å·²æ¸…æƒ"""
        if corner_id in self.corners:
            self.corners[corner_id]['status'] = 'cleaned'

    def get_next_target(self):
        """
        é¸æ“‡ä¸‹ä¸€å€‹ç›®æ¨™

        å„ªå…ˆé †åºï¼š
        1. æœªç¢ºèªçš„è§’è½ï¼ˆéœ€è¦å…ˆå»çœ‹çœ‹æ˜¯ä»€éº¼ï¼‰
        2. å·²ç¢ºèªçš„ç´™å±‘è§’è½ï¼ˆæ¸…æƒï¼‰
        3. ä¸­å¤®å€åŸŸï¼ˆæœ€å¾Œï¼Œåˆ†æ•¸ä½ï¼‰

        Returns:
            (zone_id, zone_info) æˆ– None
        """
        # 1. å„ªå…ˆè™•ç†æœªç¢ºèªçš„è§’è½ï¼ˆç”±è¿‘åˆ°é ï¼‰
        unknown_corners = [
            (cid, cinfo) for cid, cinfo in self.corners.items()
            if cinfo['status'] == 'unknown'
        ]
        if unknown_corners:
            # æŒ‰è·é›¢æ’åºï¼Œå…ˆå»è¿‘çš„
            return min(unknown_corners, key=lambda x: x[1]['distance'])

        # 2. è™•ç†å·²ç¢ºèªçš„ç´™å±‘è§’è½
        paper_corners = [
            (cid, cinfo) for cid, cinfo in self.corners.items()
            if cinfo['status'] == 'paper'
        ]
        if paper_corners:
            return min(paper_corners, key=lambda x: x[1]['distance'])

        # 3. æœ€å¾Œè™•ç†ä¸­å¤®
        if self.center['Z5']['status'] == 'paper':
            return ('Z5', self.center['Z5'])

        return None

    def get_zone_direction(self, zone_id, current_heading):
        """è¨ˆç®—åˆ°ç›®æ¨™å€åŸŸéœ€è¦è½‰å¤šå°‘åº¦"""
        if zone_id in self.corners:
            target_angle = self.corners[zone_id]['angle']
        elif zone_id == 'Z5':
            target_angle = self.center['Z5']['angle']
        else:
            return None

        turn_angle = target_angle - current_heading

        # æ­£è¦åŒ–åˆ° -180 ~ 180
        while turn_angle > 180:
            turn_angle -= 360
        while turn_angle < -180:
            turn_angle += 360

        return turn_angle

    def get_return_direction(self, current_heading):
        """è¨ˆç®—è¿”å›å…¥å£éœ€è¦è½‰çš„è§’åº¦ï¼ˆå…¥å£åœ¨ 180Â° æ–¹å‘ï¼‰"""
        turn_angle = 180 - current_heading
        while turn_angle > 180:
            turn_angle -= 360
        while turn_angle < -180:
            turn_angle += 360
        return turn_angle

    def get_all_paper_zones_cleaned(self):
        """æª¢æŸ¥æ˜¯å¦æ‰€æœ‰ç´™å±‘å€éƒ½æ¸…æƒå®Œç•¢"""
        for cinfo in self.corners.values():
            if cinfo['status'] == 'paper':  # é‚„æœ‰æœªæ¸…çš„ç´™å±‘å€
                return False
        if self.center['Z5']['status'] == 'paper':
            return False
        return True


class IMUTracker:
    """
    MPU6050 èˆªå‘è¿½è¹¤å™¨

    ç”¨é€”ï¼š
    - è¿½è¹¤æ©Ÿå™¨äººã€Œé¢å‘å“ªè£¡ã€ï¼ˆç›¸å°æ–¼å…¥å£æ–¹å‘ï¼‰
    - é…åˆé è¼‰åœ°åœ–ï¼ŒçŸ¥é“è©²å¾€å“ªè½‰
    - çŸ­æ™‚é–“å…§ç²¾åº¦è¶³å¤ 
    """

    def __init__(self):
        self.heading = 0.0  # ç•¶å‰èˆªå‘ï¼ˆåº¦ï¼‰ï¼Œ0 = å…¥å£æ–¹å‘
        self.gyro_z_offset = 0.0

    def update(self, gyro_z, dt):
        """
        æ›´æ–°èˆªå‘è§’

        Args:
            gyro_z: Z è»¸è§’é€Ÿåº¦ï¼ˆåº¦/ç§’ï¼‰
            dt: æ™‚é–“é–“éš”ï¼ˆç§’ï¼‰
        """
        corrected_gyro = gyro_z - self.gyro_z_offset
        self.heading += corrected_gyro * dt
        self.heading = self.heading % 360

    def reset_heading(self):
        """é‡ç½®èˆªå‘ç‚º 0"""
        self.heading = 0.0

    def get_heading(self):
        """å–å¾—ç•¶å‰èˆªå‘"""
        return self.heading


class SafetyLayer:
    """
    å®‰å…¨å±¤ - å¹³é †ä¿®æ­£

    æ„Ÿæ¸¬å™¨é…ç½®ï¼š
    - å·¦è¶…è²æ³¢ + å³è¶…è²æ³¢ï¼ˆå…©å´ç‰†è·ï¼‰
    - ç›¸æ©Ÿï¼ˆå‰æ–¹é»‘ç‰†ã€ç´…è‰²ç¦å€ï¼‰

    è¨­è¨ˆå“²å­¸ï¼š
    - çœ‹åˆ°ç´…è‰² = ã€Œé€™é‚Šä¸è¦å»ã€ï¼Œå¹³é †è½‰å‘
    - ä¸æ˜¯æ€¥ç…ï¼Œæ˜¯å„ªé›…ç¹é–‹
    """

    def __init__(self):
        # ===== è¶…è²æ³¢åƒæ•¸ï¼ˆå·¦+å³ï¼‰=====
        self.WALL_SLOW_DIST = 40      # cmï¼Œé–‹å§‹æ¸›é€Ÿ
        self.WALL_TURN_DIST = 25      # cmï¼Œé–‹å§‹è½‰å‘ä¿®æ­£
        self.WALL_STOP_DIST = 10      # cmï¼Œåœæ­¢

        # ===== ç´…è‰²è¦–è¦ºåƒæ•¸ =====
        self.RED_AVOID_THRESHOLD = 0.08  # ç´…è‰²ä½”ç•«é¢æ¯”ä¾‹é–¾å€¼
        self.red_lower1 = np.array([0, 100, 100])
        self.red_upper1 = np.array([10, 255, 255])
        self.red_lower2 = np.array([160, 100, 100])
        self.red_upper2 = np.array([180, 255, 255])

        # ===== å‰æ–¹é»‘ç‰†è¦–è¦ºåƒæ•¸ =====
        self.BLACK_WALL_THRESHOLD = 0.35  # ç•«é¢ä¸‹åŠéƒ¨é»‘è‰²æ¯”ä¾‹é–¾å€¼
        self.black_lower = np.array([0, 0, 0])
        self.black_upper = np.array([180, 255, 50])

    def check_and_modify(self, base_cmd, frame, left_dist, right_dist):
        """
        æª¢æŸ¥å®‰å…¨ç‹€æ…‹ä¸¦å¹³é †ä¿®æ­£æŒ‡ä»¤

        Args:
            base_cmd: (linear, angular, vacuum)
            frame: ç›¸æ©Ÿå½±åƒ
            left_dist: å·¦è¶…è²æ³¢è·é›¢ (cm)
            right_dist: å³è¶…è²æ³¢è·é›¢ (cm)

        Returns:
            modified_cmd, status ('safe'/'adjusting'/'blocked')
        """
        linear, angular, vacuum = base_cmd
        status = 'safe'

        # ===== 1. å·¦å³è¶…è²æ³¢æª¢æŸ¥ =====
        if left_dist < self.WALL_STOP_DIST or right_dist < self.WALL_STOP_DIST:
            # æŸå´å¤ªè¿‘ï¼Œåœæ­¢
            return (-0.15, 0, vacuum), 'blocked'

        # å·¦å´å¤ªè¿‘
        if left_dist < self.WALL_TURN_DIST:
            linear *= 0.5
            angular += 0.25  # å³è½‰
            status = 'adjusting'
        elif left_dist < self.WALL_SLOW_DIST:
            linear *= 0.8
            status = 'adjusting'

        # å³å´å¤ªè¿‘
        if right_dist < self.WALL_TURN_DIST:
            linear *= 0.5
            angular -= 0.25  # å·¦è½‰
            status = 'adjusting'
        elif right_dist < self.WALL_SLOW_DIST:
            linear *= 0.8
            status = 'adjusting'

        # ===== 2. å‰æ–¹é»‘ç‰†æª¢æŸ¥ï¼ˆç›¸æ©Ÿï¼Œå€åˆ†ç‰† vs è† å¸¶ï¼‰=====
        if frame is not None and linear > 0:
            is_wall, black_ratio, is_tape = self._is_wall_close(frame)
            if is_wall:
                # å‰æ–¹æœ‰ç‰†ï¼Œæ¸›é€Ÿ
                if black_ratio > 0.5:
                    linear *= 0.3  # å¾ˆè¿‘äº†
                else:
                    linear *= 0.6
                status = 'adjusting'
            # is_tape = True æ™‚ä¸æ¸›é€Ÿï¼Œè¡¨ç¤ºåˆ°é”é»‘è† å¸¶å€ï¼ˆå¯é¸ç”¨æ–¼å®šä½ç¢ºèªï¼‰

        # ===== 3. ç´…è‰²è¦–è¦ºæª¢æŸ¥ =====
        if frame is not None and linear > 0:
            red_info = self._detect_red_region(frame)

            if red_info['detected']:
                # å¹³é †ç¹é–‹
                if red_info['position'] == 'left':
                    angular = max(angular, 0.35)
                elif red_info['position'] == 'right':
                    angular = min(angular, -0.35)
                elif red_info['position'] == 'center':
                    linear *= 0.5
                    angular = 0.4 if red_info['center_x'] < 0.5 else -0.4
                status = 'adjusting'

        linear = np.clip(linear, -0.5, 0.5)
        angular = np.clip(angular, -1.0, 1.0)

        return (linear, angular, vacuum), status

    def _is_wall_close(self, frame):
        """
        åˆ†å€åˆ¤æ–·ï¼šå€åˆ†é»‘ç‰† vs é»‘è† å¸¶

        åŸç†ï¼š
        - é»‘ç‰†ï¼šç•«é¢ä¸­æ®µ+ä¸‹æ®µéƒ½æœ‰é»‘è‰²ï¼ˆå‚ç›´å»¶ä¼¸ï¼‰
        - é»‘è† å¸¶ï¼šåªæœ‰æœ€åº•éƒ¨æœ‰é»‘è‰²ï¼ˆæ°´å¹³æ¢ç‹€åœ¨åœ°æ¿ä¸Šï¼‰

        Returns:
            (is_wall: bool, black_ratio: float, is_tape: bool)
        """
        h, w = frame.shape[:2]

        # åˆ†æˆä¸‰å€
        mid_region = frame[h//3:2*h//3, :]     # ä¸­ 1/3
        bottom_region = frame[2*h//3:, :]      # ä¸‹ 1/3

        def get_black_ratio(region):
            hsv = cv2.cvtColor(region, cv2.COLOR_BGR2HSV)
            black_mask = cv2.inRange(hsv, self.black_lower, self.black_upper)
            return cv2.countNonZero(black_mask) / black_mask.size

        mid_black = get_black_ratio(mid_region)
        bottom_black = get_black_ratio(bottom_region)

        # é»‘ç‰†ï¼šä¸­æ®µ+åº•éƒ¨éƒ½é»‘ï¼ˆå‚ç›´å»¶ä¼¸ï¼‰
        is_wall = mid_black > 0.25 and bottom_black > 0.30

        # é»‘è† å¸¶ï¼šåªæœ‰åº•éƒ¨é»‘ï¼Œä¸­æ®µä¸é»‘
        is_tape = bottom_black > 0.30 and mid_black < 0.15

        return is_wall, bottom_black, is_tape

    def _detect_red_region(self, frame):
        """åµæ¸¬ç´…è‰²å€åŸŸ"""
        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)

        mask1 = cv2.inRange(hsv, self.red_lower1, self.red_upper1)
        mask2 = cv2.inRange(hsv, self.red_lower2, self.red_upper2)
        red_mask = cv2.bitwise_or(mask1, mask2)

        h, w = frame.shape[:2]
        red_pixels = cv2.countNonZero(red_mask)
        red_ratio = red_pixels / (h * w)

        if red_ratio < self.RED_AVOID_THRESHOLD:
            return {'detected': False, 'position': None, 'ratio': red_ratio}

        moments = cv2.moments(red_mask)
        if moments['m00'] > 0:
            cx = moments['m10'] / moments['m00']
            center_x = cx / w

            if center_x < 0.35:
                position = 'left'
            elif center_x > 0.65:
                position = 'right'
            else:
                position = 'center'
        else:
            position = 'center'
            center_x = 0.5

        return {
            'detected': True,
            'position': position,
            'ratio': red_ratio,
            'center_x': center_x
        }

    def is_red_zone_ahead(self, frame):
        """
        åˆ¤æ–·å‰æ–¹æ˜¯å¦æ˜¯ç´…å€ï¼ˆç”¨æ–¼è§’è½ç¢ºèªï¼‰

        Returns:
            True å¦‚æœå‰æ–¹å¤§ç‰‡ç´…è‰²ï¼ˆç´…å€ï¼‰
        """
        if frame is None:
            return False

        red_info = self._detect_red_region(frame)
        # æ›´é«˜é–¾å€¼ï¼Œç¢ºèªæ˜¯çœŸçš„ç´…å€è€Œéè·¯é
        return red_info['detected'] and red_info['ratio'] > 0.2


class HybridNavigator:
    """
    æ··åˆå°èˆªæ§åˆ¶å™¨

    æµç¨‹ï¼š
    1. å¾é è¼‰åœ°åœ–é¸æ“‡ä¸‹ä¸€å€‹è§’è½
    2. ç”¨ IMU è¨ˆç®—è½‰å‘è§’åº¦
    3. å‰é€²åˆ°è§’è½é™„è¿‘
    4. è¦–è¦ºç¢ºèªï¼šç´…å€é‚„æ˜¯ç´™å±‘å€ï¼Ÿ
       - ç´…å€ â†’ æ¨™è¨˜ä¸¦è·³é
       - ç´™å±‘å€ â†’ æ¸…æƒ
    5. é‡è¤‡ç›´åˆ°æ‰€æœ‰å€åŸŸå®Œæˆ
    6. è¿”å›å…¥å£
    """

    def __init__(self):
        self.field_map = PreloadedFieldMap()
        self.imu = IMUTracker()
        self.safety = SafetyLayer()

        self.current_target = None
        self.state = 'INIT'
        # INIT, TURNING, APPROACHING, CONFIRMING, CLEANING, RETURNING, DONE

        self.approach_start_time = None
        self.APPROACH_TIMEOUT = 5.0  # å‰é€²è¶…æ™‚ï¼ˆç§’ï¼‰

    def compute_command(self, frame, left_dist, right_dist, gyro_z, dt):
        """
        ä¸»æ§åˆ¶å‡½æ•¸

        Args:
            frame: ç›¸æ©Ÿå½±åƒ
            left_dist, right_dist: è¶…è²æ³¢è·é›¢ (cm)
            gyro_z: é™€èºå„€ Z è»¸è§’é€Ÿåº¦
            dt: æ™‚é–“é–“éš”

        Returns:
            (linear, angular, vacuum)
        """
        # æ›´æ–° IMU
        self.imu.update(gyro_z, dt)
        current_heading = self.imu.get_heading()

        if self.state == 'INIT':
            self.imu.reset_heading()
            self._select_next_target()
            if self.current_target:
                self.state = 'TURNING'
                print(f"[å°èˆª] ç›®æ¨™: {self.current_target[0]}")
            else:
                self.state = 'RETURNING'
            return (0, 0, False)

        elif self.state == 'TURNING':
            zone_id, zone_info = self.current_target
            turn_angle = self.field_map.get_zone_direction(zone_id, current_heading)

            if abs(turn_angle) < 15:  # å°æº–äº†
                self.state = 'APPROACHING'
                self.approach_start_time = None
                print(f"[å°èˆª] å°æº– {zone_id}ï¼Œé–‹å§‹å‰é€²")
                return (0, 0, False)
            else:
                angular = np.clip(turn_angle / 45, -0.4, 0.4)
                return (0, angular, False)

        elif self.state == 'APPROACHING':
            # è¨˜éŒ„é–‹å§‹æ™‚é–“
            import time
            if self.approach_start_time is None:
                self.approach_start_time = time.time()

            zone_id, zone_info = self.current_target

            # è¶…æ™‚æª¢æŸ¥ï¼ˆæ‡‰è©²å·²ç¶“åˆ°äº†ï¼‰
            elapsed = time.time() - self.approach_start_time
            if elapsed > self.APPROACH_TIMEOUT:
                self.state = 'CONFIRMING'
                print(f"[å°èˆª] åˆ°é” {zone_id} é™„è¿‘ï¼Œç¢ºèªä¸­...")
                return (0, 0, False)

            # åŸºç¤æŒ‡ä»¤ï¼šå‰é€²
            base_cmd = (0.35, 0, False)

            # å®‰å…¨å±¤ä¿®æ­£
            safe_cmd, status = self.safety.check_and_modify(
                base_cmd, frame, left_dist, right_dist
            )

            return safe_cmd

        elif self.state == 'CONFIRMING':
            zone_id, zone_info = self.current_target

            # è¦–è¦ºç¢ºèªï¼šç´…å€é‚„æ˜¯ç´™å±‘å€ï¼Ÿ
            if self.safety.is_red_zone_ahead(frame):
                # æ˜¯ç´…å€ï¼æ¨™è¨˜ä¸¦è·³é
                self.field_map.mark_corner_as_red(zone_id)
                print(f"[å°èˆª] {zone_id} æ˜¯ç´…å€ï¼Œè·³é")
                self._select_next_target()
                if self.current_target:
                    self.state = 'TURNING'
                else:
                    self.state = 'RETURNING'
            else:
                # æ˜¯ç´™å±‘å€ï¼Œé–‹å§‹æ¸…æƒ
                self.field_map.mark_corner_as_paper(zone_id)
                self.state = 'CLEANING'
                print(f"[å°èˆª] {zone_id} æ˜¯ç´™å±‘å€ï¼Œé–‹å§‹æ¸…æƒ")

            return (0, 0, False)

        elif self.state == 'CLEANING':
            zone_id, zone_info = self.current_target

            # åµæ¸¬ç´™å±‘
            paper_info = self._detect_paper(frame)

            if paper_info['found']:
                # è¿½è¹¤ç´™å±‘
                angular = paper_info['offset_x'] * 0.4
                base_cmd = (0.25, angular, True)
                safe_cmd, _ = self.safety.check_and_modify(
                    base_cmd, frame, left_dist, right_dist
                )
                return safe_cmd
            else:
                # æ²’çœ‹åˆ°ç´™å±‘ï¼Œå®Œæˆé€™å€
                self.field_map.mark_corner_cleaned(zone_id)
                print(f"[å°èˆª] {zone_id} æ¸…æƒå®Œæˆ")
                self._select_next_target()
                if self.current_target:
                    self.state = 'TURNING'
                else:
                    self.state = 'RETURNING'
                return (0, 0, False)

        elif self.state == 'RETURNING':
            turn_angle = self.field_map.get_return_direction(current_heading)

            if abs(turn_angle) > 15:
                angular = np.clip(turn_angle / 45, -0.4, 0.4)
                return (0, angular, False)
            else:
                base_cmd = (0.4, 0, False)
                safe_cmd, _ = self.safety.check_and_modify(
                    base_cmd, frame, left_dist, right_dist
                )
                return safe_cmd

        return (0, 0, False)

    def _select_next_target(self):
        """é¸æ“‡ä¸‹ä¸€å€‹ç›®æ¨™"""
        self.current_target = self.field_map.get_next_target()

    def _detect_paper(self, frame):
        """åµæ¸¬ç´™å±‘"""
        if frame is None:
            return {'found': False}

        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)

        white_lower = np.array([0, 0, 180])
        white_upper = np.array([180, 50, 255])
        white_mask = cv2.inRange(hsv, white_lower, white_upper)

        kernel = np.ones((5, 5), np.uint8)
        white_mask = cv2.morphologyEx(white_mask, cv2.MORPH_OPEN, kernel)

        contours, _ = cv2.findContours(white_mask, cv2.RETR_EXTERNAL,
                                       cv2.CHAIN_APPROX_SIMPLE)

        valid_papers = []
        h, w = frame.shape[:2]

        for cnt in contours:
            area = cv2.contourArea(cnt)
            if 200 < area < 3000:
                M = cv2.moments(cnt)
                if M['m00'] > 0:
                    cx = int(M['m10'] / M['m00'])
                    cy = int(M['m01'] / M['m00'])
                    valid_papers.append({
                        'cx': cx, 'cy': cy,
                        'offset_x': (cx - w/2) / (w/2)
                    })

        if valid_papers:
            nearest = max(valid_papers, key=lambda p: p['cy'])
            return {'found': True, 'offset_x': nearest['offset_x']}

        return {'found': False}
```

### 0.2 Arduino ç«¯ MPU6050 æ•´åˆ

```cpp
// Arduino æ–°å¢ MPU6050
#include <Wire.h>

const int MPU_ADDR = 0x68;
float gyro_z_offset = 0;

void setupMPU6050() {
    Wire.begin();
    Wire.beginTransmission(MPU_ADDR);
    Wire.write(0x6B);
    Wire.write(0);
    Wire.endTransmission();

    // Â±250Â°/s
    Wire.beginTransmission(MPU_ADDR);
    Wire.write(0x1B);
    Wire.write(0x00);
    Wire.endTransmission();

    calibrateGyro();
}

void calibrateGyro() {
    float sum = 0;
    for (int i = 0; i < 200; i++) {
        sum += readRawGyroZ();
        delay(10);
    }
    gyro_z_offset = sum / 200;
}

float readRawGyroZ() {
    Wire.beginTransmission(MPU_ADDR);
    Wire.write(0x47);
    Wire.endTransmission(false);
    Wire.requestFrom(MPU_ADDR, 2, true);
    int16_t raw = Wire.read() << 8 | Wire.read();
    return raw / 131.0;
}

float getGyroZ() {
    return readRawGyroZ() - gyro_z_offset;
}

// Serial æ ¼å¼: "L:xx,R:xx,G:xx.xx"
void sendSensorData() {
    Serial.print("L:");
    Serial.print(leftDistance);
    Serial.print(",R:");
    Serial.print(rightDistance);
    Serial.print(",G:");
    Serial.println(getGyroZ(), 2);
}
```

### 0.3 ç³»çµ±æ•´åˆç¯„ä¾‹

```python
# autonomous_main.py

import cv2
import time
import serial

class AutonomousRobot:
    def __init__(self):
        self.navigator = HybridNavigator()
        self.camera = cv2.VideoCapture(0)
        self.arduino = serial.Serial('/dev/ttyUSB0', 9600, timeout=0.1)

        self.last_time = time.time()

    def parse_sensor_data(self, line):
        """è§£æ Arduino æ•¸æ“š: L:xx,R:xx,G:xx.xx"""
        try:
            parts = line.strip().split(',')
            left = int(parts[0].split(':')[1])
            right = int(parts[1].split(':')[1])
            gyro = float(parts[2].split(':')[1])
            return left, right, gyro
        except:
            return 100, 100, 0  # é è¨­å€¼

    def send_command(self, linear, angular, vacuum):
        """ç™¼é€æŒ‡ä»¤åˆ° Arduino"""
        # è½‰æ›æˆé¦¬é” PWM
        left_pwm = int((linear - angular) * 255)
        right_pwm = int((linear + angular) * 255)
        left_pwm = max(-255, min(255, left_pwm))
        right_pwm = max(-255, min(255, right_pwm))

        vac = 1 if vacuum else 0
        cmd = f"M:{left_pwm},{right_pwm},{vac}\n"
        self.arduino.write(cmd.encode())

    def run(self):
        print("[ç³»çµ±] è‡ªèµ°æ¨¡å¼å•Ÿå‹•")

        while True:
            # è¨ˆç®— dt
            now = time.time()
            dt = now - self.last_time
            self.last_time = now

            # è®€å–ç›¸æ©Ÿ
            ret, frame = self.camera.read()
            if not ret:
                frame = None

            # è®€å–æ„Ÿæ¸¬å™¨
            if self.arduino.in_waiting:
                line = self.arduino.readline().decode()
                left_dist, right_dist, gyro_z = self.parse_sensor_data(line)
            else:
                left_dist, right_dist, gyro_z = 100, 100, 0

            # è¨ˆç®—å°èˆªæŒ‡ä»¤
            linear, angular, vacuum = self.navigator.compute_command(
                frame, left_dist, right_dist, gyro_z, dt
            )

            # ç™¼é€æŒ‡ä»¤
            self.send_command(linear, angular, vacuum)

            # æª¢æŸ¥å®Œæˆ
            if self.navigator.state == 'DONE':
                print("[ç³»çµ±] ä»»å‹™å®Œæˆï¼")
                break

            time.sleep(0.05)  # 20 Hz

        self.send_command(0, 0, False)
        self.camera.release()

if __name__ == '__main__':
    robot = AutonomousRobot()
    robot.run()
```

---

## ä¸€ã€ç«¶è³½åˆ†æ

### 1.1 ç«¶è³½è¦å‰‡

#### è©•åˆ†ç³»çµ±
- **æ™‚é–“åˆ†ï¼ˆç´šè·å¼ï¼‰**
  - ç´šè·åˆ¶è©•åˆ†ï¼ˆä¾‹ï¼š< 2:00 æ»¿åˆ†ï¼Œ2:00-2:30 æ¬¡ç´šï¼Œ> 2:30 å†æ¬¡ç´šï¼‰
  - **è­¦å‘Šï¼š** è‹¥ç´™å±‘ < 30 ç‰‡ï¼Œæ™‚é–“åˆ†æ‰“ **å…«æŠ˜**

- **ç´™å±‘åˆ†**
  - ç›®æ¨™ï¼š80 ç‰‡ï¼ˆæ»¿åˆ†ï¼‰
  - ä¸­é–“å€åŸŸç´™å±‘åˆ†æ•¸è¼ƒä½ï¼ˆæœŸä¸­ç¶“é©—ï¼‰
  - **ç­–ç•¥å•Ÿç¤ºï¼š** å„ªå…ˆæ¸…æƒè§’è½ 4 å€ï¼Œä¸­é–“å€è¦–æ™‚é–“æ±ºå®š

- **ç´…è‰²ç¦å€**
  - ç¢°åˆ°æœƒæ‰£åˆ†/å¤±æ ¼

#### é—œéµç´„æŸ
- ğŸš« **ç„¡ç·¨ç¢¼å™¨** - ç„¡æ³•ç²¾ç¢ºèˆªä½æ¨ç®—
- ğŸšª **å¿…é ˆé›¢å ´** - æœªé›¢å ´è¦–ç‚ºå¤±æ•—

### 1.2 å ´åœ°è³‡è¨Šï¼ˆæ ¹æ“šæœŸä¸­ç¶“é©—ï¼‰
- ğŸ“ **ç´™å±‘åˆ†å¸ƒ**ï¼šé›†ä¸­åœ¨ 5 å€‹å€åŸŸï¼ˆ4 å€‹è§’è½ä¸è²¼ç‰† + ä¸­å¤®ï¼‰ï¼Œç¸½è¨ˆç´„ 80 ç‰‡
- â¬› **é»‘è‰²è† å¸¶æ¨™è¨˜**ï¼šç´™å±‘é›†ä¸­å€åŸŸæœƒç”¨é»‘è‰²è† å¸¶æ¨™ç¤º
- ğŸ”´ **ç´…è‰²è† å¸¶æ¨™è¨˜**ï¼šç´…è‰²ç¦å€æœƒç”¨ç´…è‰²è† å¸¶æ¨™ç¤º
- ğŸ“ **å ´åœ°å½¢ç‹€**ï¼šæ–¹å½¢å ´åœ°ï¼ˆæœŸä¸­ï¼‰ï¼ŒæœŸæœ«æ‡‰é¡ä¼¼

### 1.3 å¯ç”¨è³‡æº
- âœ… **USB Camera** - 640x480 @ 30 FPSï¼Œä½ä½å®‰è£å¯çœ‹åˆ°è¿‘è™•ç´™å±‘èˆ‡æ•´å€‹å ´åœ°
- âœ… **è¶…è²æ³¢ Ã— 2** - å·¦å³æ¸¬è·ï¼ˆéœ€æ”¹éé˜»å¡ï¼‰
- âœ… **å·®å‹•é©…å‹•** - å·²é©—è­‰ç©©å®š
- âœ… **Raspberry Pi 4** - OpenCV å¯¦æ™‚è™•ç†

---

## äºŒã€æ ¸å¿ƒç­–ç•¥ï¼šå€åŸŸç›®æ¨™å°å‘æ¸…æƒ

### 2.1 é—œéµæ´å¯Ÿ

**è† å¸¶æ¨™è¨˜ = å°èˆªåœ°æ¨™ + ç›®æ¨™æŒ‡ç¤º**

âŒ **å‚³çµ±ç›²ç›®è¦†è“‹**ï¼š
- æ²¿ç‰†/èºæ—‹/Zigzag æµªè²»æ™‚é–“
- ç„¡ç·¨ç¢¼å™¨æœƒç´¯ç©èª¤å·®
- é›£ä»¥è¿”èˆªé›¢å ´

âœ… **æ™ºæ…§ç›®æ¨™å°å‘**ï¼š
- ğŸ¯ **é»‘è‰²è† å¸¶ = ç´™å±‘å€åŸŸ**ï¼ˆç›´æ¥å‰å¾€æ¸…æƒï¼‰
- ğŸš« **ç´…è‰²è† å¸¶ = ç¦å€**ï¼ˆé¿é–‹ï¼‰
- ğŸ“· **è¦–è¦ºç¢ºèª = é–‰ç’°æ§åˆ¶**ï¼ˆä¸ç´¯ç©èª¤å·®ï¼‰
- âš¡ **æ•ˆç‡å„ªå…ˆ**ï¼šç›´é”ç›®æ¨™ï¼Œä¸åšç„¡ç”¨åŠŸ

### 2.2 ä¸‰éšæ®µç­–ç•¥

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Phase 1: å…¥å ´å…¨åŸŸæƒæ (5-10 ç§’)                 â”‚
â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”‚
â”‚ ç›®æ¨™ï¼šè­˜åˆ¥é»‘è‰²ç´™å±‘å€ã€ç´…è‰²ç¦å€ã€å…¥å£ç‰¹å¾µ       â”‚
â”‚                                                 â”‚
â”‚ 1. åœ¨å…¥å£åœç•™ï¼Œ360Â° åŸåœ°æ—‹è½‰æƒæ               â”‚
â”‚ 2. åµæ¸¬ä¸¦è¨˜éŒ„ã€Œé»‘è‰²è† å¸¶å€åŸŸã€ï¼ˆç´™å±‘ç›®æ¨™ï¼‰     â”‚
â”‚    â†’ è¨˜éŒ„æ–¹å‘ã€è·é›¢ã€å¤§å°                      â”‚
â”‚ 3. åµæ¸¬ä¸¦è¨˜éŒ„ã€Œç´…è‰²è† å¸¶å€åŸŸã€ï¼ˆç¦å€ï¼‰         â”‚
â”‚    â†’ è¨˜éŒ„æ–¹å‘ã€è·é›¢ï¼ˆç”¨æ–¼é¿éšœï¼‰               â”‚
â”‚ 4. è¨˜éŒ„å…¥å£è¦–è¦ºç‰¹å¾µï¼ˆSIFT/ORBï¼Œç”¨æ–¼è¿”å›ï¼‰     â”‚
â”‚ 5. è¦åŠƒå€åŸŸè¨ªå•é †åºï¼ˆç”±è¿‘åˆ°é ã€é¿é–‹ç´…å€ï¼‰     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Phase 2: å€åŸŸå°å‘æ¸…æƒ (ä¸»è¦æ™‚é–“)               â”‚
â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”‚
â”‚ ç›®æ¨™ï¼šé€ä¸€å‰å¾€é»‘è‰²æ¨™è¨˜å€åŸŸï¼Œæ¸…æƒç´™å±‘           â”‚
â”‚                                                 â”‚
â”‚ ã€å€åŸŸé–“å°èˆªã€‘                                  â”‚
â”‚ 1. é¸æ“‡ä¸‹ä¸€å€‹æœªæ¸…æƒçš„é»‘è‰²å€åŸŸ                   â”‚
â”‚ 2. è¦–è¦ºå°èˆªå‰å¾€ï¼ˆæŒçºŒè¿½è¹¤é»‘è‰²è† å¸¶ï¼‰           â”‚
â”‚ 3. éç¨‹ä¸­å³æ™‚ç´…è‰²é¿éšœï¼ˆè¦–è¦º+è¶…è²æ³¢ï¼‰           â”‚
â”‚                                                 â”‚
â”‚ ã€å€åŸŸå…§æ¸…æƒã€‘                                  â”‚
â”‚ 1. åˆ°é”é»‘è‰²å€åŸŸå¾Œï¼Œå•Ÿå‹•å¸å¡µå™¨                   â”‚
â”‚ 2. è¦–è¦ºè­˜åˆ¥ç´™å±‘ï¼ˆç™½è‰²/æ·ºè‰²ç‰©é«”ï¼‰               â”‚
â”‚ 3. é€å€‹é è¿‘ä¸¦æ¸…æƒç´™å±‘                           â”‚
â”‚ 4. å°ç¯„åœç§»å‹•ç¢ºä¿å®Œå…¨æ¸…æƒ                       â”‚
â”‚ 5. è¦–è¦ºç¢ºèªç„¡ç´™å±‘ â†’ å‰å¾€ä¸‹ä¸€å€åŸŸ               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Phase 3: è¦–è¦ºè¿”èˆª (10-15 ç§’)                   â”‚
â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”‚
â”‚ ç›®æ¨™ï¼šå¿«é€Ÿè¿”å›å‡ºå£é›¢å ´                         â”‚
â”‚                                                 â”‚
â”‚ 1. æ‰€æœ‰å€åŸŸæ¸…æƒå®Œæˆ â†’ æ—‹è½‰å°‹æ‰¾å…¥å£ç‰¹å¾µ         â”‚
â”‚ 2. è¦–è¦ºç‰¹å¾µåŒ¹é…ï¼ˆSIFT matchingï¼‰               â”‚
â”‚ 3. å°æº–å…¥å£æ–¹å‘ä¸¦å‰é€²                           â”‚
â”‚ 4. è¦–è¦ºç¢ºèªåˆ°é” â†’ åœæ­¢                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ä¸‰ã€æŠ€è¡“å¯¦ç¾

### 3.1 è¦–è¦ºåµæ¸¬ç³»çµ±

#### é»‘è‰²è† å¸¶å€åŸŸåµæ¸¬ï¼ˆç´™å±‘ç›®æ¨™å€ï¼‰
```python
class BlackTapeZoneDetector:
    """åµæ¸¬é»‘è‰²è† å¸¶æ¨™è¨˜çš„ç´™å±‘é›†ä¸­å€åŸŸ"""

    def __init__(self):
        # é»‘è‰² HSV ç¯„åœ
        self.black_lower = np.array([0, 0, 0])
        self.black_upper = np.array([180, 255, 50])

        # å·²ç™¼ç¾çš„å€åŸŸ
        self.zones = []

    def detect_zones(self, frame, robot_heading=0):
        """
        åµæ¸¬é»‘è‰²è† å¸¶å€åŸŸä¸¦è¨˜éŒ„

        Args:
            frame: ç•¶å‰å½±åƒ
            robot_heading: ç•¶å‰æœå‘è§’åº¦ (åº¦)

        Returns:
            zones: é»‘è‰²å€åŸŸåˆ—è¡¨ [(angle, distance, size), ...]
        """
        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)

        # é»‘è‰²é®ç½©
        black_mask = cv2.inRange(hsv, self.black_lower, self.black_upper)

        # å½¢æ…‹å­¸è™•ç†ï¼ˆå¡«è£œæ–·è£‚çš„è† å¸¶ï¼‰
        kernel = np.ones((5, 5), np.uint8)
        black_mask = cv2.morphologyEx(black_mask, cv2.MORPH_CLOSE, kernel)

        # æ‰¾è¼ªå»“
        contours, _ = cv2.findContours(black_mask, cv2.RETR_EXTERNAL,
                                       cv2.CHAIN_APPROX_SIMPLE)

        detected_zones = []
        h, w = frame.shape[:2]

        for cnt in contours:
            area = cv2.contourArea(cnt)

            # éæ¿¾å¤ªå°çš„é›œè¨Šï¼ˆè† å¸¶æ‡‰è©²æœ‰ä¸€å®šå¤§å°ï¼‰
            if area < 800:
                continue

            # è¨ˆç®—é‡å¿ƒ
            M = cv2.moments(cnt)
            if M['m00'] == 0:
                continue
            cx = int(M['m10'] / M['m00'])
            cy = int(M['m01'] / M['m00'])

            # è¨ˆç®—ç›¸å°è§’åº¦ï¼ˆç•«é¢ä¸­å¿ƒ = æ­£å‰æ–¹ï¼‰
            angle_offset = (cx - w/2) / (w/2) * 30  # å‡è¨­ç›¸æ©Ÿ FOV 60Â°
            absolute_angle = (robot_heading + angle_offset) % 360

            # ä¼°ç®—è·é›¢ï¼ˆè¶Šé ä¸‹è¶Šè¿‘ï¼‰
            distance = self._estimate_distance(area, cy, h)

            zone = {
                'angle': absolute_angle,
                'distance': distance,
                'size': area,
                'pixel_pos': (cx, cy),
                'cleaned': False
            }

            detected_zones.append(zone)

        return detected_zones

    def _estimate_distance(self, area, cy, frame_height):
        """åŸºæ–¼è¦–è¦ºå¤§å°å’Œå‚ç›´ä½ç½®ä¼°ç®—è·é›¢"""
        # å‚ç›´ä½ç½®å› å­ï¼ˆè¶Šé è¿‘ç•«é¢åº•éƒ¨è¶Šè¿‘ï¼‰
        vertical_factor = cy / frame_height

        # é¢ç©å› å­ï¼ˆéœ€å¯¦éš›æ ¡æº–ï¼‰
        if area > 3000:
            base_dist = 0.4  # 40cm
        elif area > 1500:
            base_dist = 0.8  # 80cm
        else:
            base_dist = 1.2  # 1.2m

        # ç¶œåˆä¿®æ­£
        distance = base_dist * (2.0 - vertical_factor)
        return max(0.2, distance)  # æœ€å° 20cm

    def add_zones(self, new_zones):
        """å°‡æ–°åµæ¸¬åˆ°çš„å€åŸŸåŠ å…¥åœ°åœ–ï¼ˆå»é‡ï¼‰"""
        for new_zone in new_zones:
            # æª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨ï¼ˆè§’åº¦ç›¸è¿‘ Â±15Â°ï¼‰
            is_duplicate = False
            for existing in self.zones:
                angle_diff = abs(new_zone['angle'] - existing['angle'])
                if angle_diff < 15 or angle_diff > 345:
                    is_duplicate = True
                    break

            if not is_duplicate:
                self.zones.append(new_zone)

    def get_nearest_unvisited_zone(self):
        """ç²å–æœ€è¿‘çš„æœªæ¸…æƒå€åŸŸ"""
        unvisited = [z for z in self.zones if not z['cleaned']]
        if not unvisited:
            return None
        return min(unvisited, key=lambda z: z['distance'])

    def mark_zone_cleaned(self, zone):
        """æ¨™è¨˜å€åŸŸå·²æ¸…æƒ"""
        zone['cleaned'] = True


class RedTapeZoneDetector:
    """åµæ¸¬ç´…è‰²è† å¸¶ç¦å€"""

    def __init__(self):
        # ç´…è‰² HSV ç¯„åœï¼ˆå…©æ®µï¼Œå› ç‚ºç´…è‰²è·¨è¶Š 0Â°ï¼‰
        self.red_lower1 = np.array([0, 100, 100])
        self.red_upper1 = np.array([10, 255, 255])
        self.red_lower2 = np.array([160, 100, 100])
        self.red_upper2 = np.array([180, 255, 255])

        self.red_zones = []

    def detect_red_zones(self, frame, robot_heading=0):
        """åµæ¸¬ç´…è‰²ç¦å€"""
        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)

        # ç´…è‰²é®ç½©ï¼ˆå…©æ®µåˆä½µï¼‰
        mask1 = cv2.inRange(hsv, self.red_lower1, self.red_upper1)
        mask2 = cv2.inRange(hsv, self.red_lower2, self.red_upper2)
        red_mask = cv2.bitwise_or(mask1, mask2)

        # å½¢æ…‹å­¸è™•ç†
        kernel = np.ones((5, 5), np.uint8)
        red_mask = cv2.morphologyEx(red_mask, cv2.MORPH_CLOSE, kernel)

        contours, _ = cv2.findContours(red_mask, cv2.RETR_EXTERNAL,
                                       cv2.CHAIN_APPROX_SIMPLE)

        detected_zones = []
        h, w = frame.shape[:2]

        for cnt in contours:
            area = cv2.contourArea(cnt)
            if area < 500:
                continue

            M = cv2.moments(cnt)
            if M['m00'] == 0:
                continue
            cx = int(M['m10'] / M['m00'])
            cy = int(M['m01'] / M['m00'])

            angle_offset = (cx - w/2) / (w/2) * 30
            absolute_angle = (robot_heading + angle_offset) % 360

            detected_zones.append({
                'angle': absolute_angle,
                'distance': self._estimate_distance(area, cy, h),
                'size': area,
                'pixel_pos': (cx, cy)
            })

        return detected_zones

    def _estimate_distance(self, area, cy, frame_height):
        """åŒé»‘è‰²è† å¸¶çš„è·é›¢ä¼°ç®—"""
        vertical_factor = cy / frame_height
        if area > 3000:
            base_dist = 0.3
        elif area > 1500:
            base_dist = 0.7
        else:
            base_dist = 1.0
        return max(0.2, base_dist * (2.0 - vertical_factor))

    def is_red_ahead(self, frame):
        """å³æ™‚åµæ¸¬ï¼šå‰æ–¹æ˜¯å¦æœ‰ç´…è‰²ï¼ˆé¿éšœç”¨ï¼‰"""
        zones = self.detect_red_zones(frame, 0)

        for zone in zones:
            # å‰æ–¹ Â±20Â° ç¯„åœå…§æœ‰ç´…è‰²
            if abs(zone['angle']) < 20 and zone['distance'] < 0.5:
                return True, zone['angle']

        return False, None
```

#### å…¥å£è¦–è¦ºç‰¹å¾µè¨˜éŒ„
```python
class EntranceDetector:
    def __init__(self):
        self.entrance_features = None
        self.entrance_sift = cv2.SIFT_create()

    def memorize_entrance(self, frame):
        """è¨˜éŒ„å…¥å£çš„è¦–è¦ºç‰¹å¾µ"""
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

        # æå– SIFT ç‰¹å¾µé»
        keypoints, descriptors = self.entrance_sift.detectAndCompute(gray, None)

        self.entrance_features = {
            'keypoints': keypoints,
            'descriptors': descriptors,
            'template': gray.copy()
        }

    def find_entrance_direction(self, frame):
        """
        åœ¨ç•¶å‰ç•«é¢ä¸­å°‹æ‰¾å…¥å£æ–¹å‘

        Returns:
            angle: å…¥å£ç›¸å°è§’åº¦ (åº¦)ï¼ŒNone è¡¨ç¤ºæœªæ‰¾åˆ°
        """
        if self.entrance_features is None:
            return None

        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        kp, desc = self.entrance_sift.detectAndCompute(gray, None)

        # ç‰¹å¾µåŒ¹é…
        bf = cv2.BFMatcher()
        matches = bf.knnMatch(self.entrance_features['descriptors'], desc, k=2)

        # Lowe's ratio test
        good_matches = []
        for m, n in matches:
            if m.distance < 0.75 * n.distance:
                good_matches.append(m)

        if len(good_matches) < 10:  # åŒ¹é…é»å¤ªå°‘
            return None

        # è¨ˆç®—åŒ¹é…é»çš„å¹³å‡ä½ç½®
        h, w = frame.shape[:2]
        avg_x = np.mean([kp[m.trainIdx].pt[0] for m in good_matches])

        # è½‰æ›ç‚ºè§’åº¦
        angle_offset = (avg_x - w/2) / (w/2) * 30  # è¦–é‡ 60Â°

        return angle_offset
```

### 3.2 ç´™å±‘åµæ¸¬èˆ‡å®šä½

```python
class PaperDetector:
    def __init__(self):
        # ç™½è‰²/æ·ºè‰²ç´™å±‘çš„ HSV ç¯„åœ
        self.paper_lower = np.array([0, 0, 180])
        self.paper_upper = np.array([180, 50, 255])

    def detect_papers(self, frame):
        """
        åµæ¸¬ç´™å±‘ä½ç½®

        Returns:
            papers: [(x, y, size), ...] ç›¸å°ä½ç½®
        """
        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)

        # ç™½è‰²é®ç½©
        paper_mask = cv2.inRange(hsv, self.paper_lower, self.paper_upper)

        # å½¢æ…‹å­¸è™•ç†
        kernel = np.ones((5,5), np.uint8)
        paper_mask = cv2.morphologyEx(paper_mask, cv2.MORPH_CLOSE, kernel)
        paper_mask = cv2.morphologyEx(paper_mask, cv2.MORPH_OPEN, kernel)

        # æ‰¾è¼ªå»“
        contours, _ = cv2.findContours(paper_mask, cv2.RETR_EXTERNAL,
                                       cv2.CHAIN_APPROX_SIMPLE)

        papers = []
        h, w = frame.shape[:2]

        for cnt in contours:
            area = cv2.contourArea(cnt)

            # éæ¿¾å¤§å° (èª¿æ•´ç¯„åœ)
            if 200 < area < 3000:
                M = cv2.moments(cnt)
                if M['m00'] > 0:
                    cx = int(M['m10'] / M['m00'])
                    cy = int(M['m01'] / M['m00'])

                    # è¨ˆç®—ç›¸å°ä½ç½®
                    rel_x = (cx - w/2) / (w/2)  # -1 ~ +1
                    rel_y = (cy - h/2) / (h/2)

                    papers.append({
                        'rel_x': rel_x,
                        'rel_y': rel_y,
                        'size': area,
                        'pixel_pos': (cx, cy)
                    })

        return papers

    def get_nearest_paper(self, papers):
        """å–å¾—æœ€è¿‘çš„ç´™å±‘ï¼ˆç•«é¢æœ€ä¸‹æ–¹ï¼‰"""
        if not papers:
            return None
        return max(papers, key=lambda p: p['rel_y'])
```

### 3.3 æ™ºèƒ½ä»»å‹™ç®¡ç†å™¨

```python
class MissionPlanner:
    """
    æ™ºèƒ½ä»»å‹™è¦åŠƒèˆ‡æ™‚é–“ç®¡ç†

    æ ¹æ“šç«¶è³½è¦å‰‡å‹•æ…‹èª¿æ•´ç­–ç•¥ï¼š
    - æ™‚é–“åˆ†ç´šè·åˆ¶
    - < 30 ç‰‡ç´™å±‘ â†’ æ™‚é–“åˆ†æ‰“å…«æŠ˜
    - ä¸­é–“å€åŸŸåˆ†æ•¸ä½ â†’ å„ªå…ˆè§’è½
    """

    def __init__(self):
        # ç«¶è³½è¦å‰‡åƒæ•¸
        self.PAPER_TOTAL = 80           # ç¸½ç´™å±‘æ•¸
        self.PAPER_PENALTY_THRESHOLD = 30  # ä½æ–¼æ­¤æ•¸é‡æ™‚é–“åˆ†æ‰“å…«æŠ˜

        # æ™‚é–“ç´šè·ï¼ˆéœ€æ ¹æ“šå¯¦éš›è¦å‰‡èª¿æ•´ï¼‰
        self.TIME_TIER_1 = 120  # 2:00 (æ»¿åˆ†)
        self.TIME_TIER_2 = 150  # 2:30 (æ¬¡ç´š)
        self.TIME_TIER_3 = 180  # 3:00 (å†æ¬¡ç´š)

        self.RETURN_TIME_MARGIN = 20  # è¿”èˆªå®‰å…¨é¤˜è£•ï¼ˆç§’ï¼‰

        # å€åŸŸå„ªå…ˆç´šï¼ˆè§’è½ > ä¸­é–“ï¼‰
        self.ZONE_PRIORITY = {
            'corner': 1.0,    # è§’è½å€åŸŸå„ªå…ˆç´šé«˜
            'center': 0.5     # ä¸­é–“å€åŸŸå„ªå…ˆç´šä½ï¼ˆåˆ†æ•¸ä½ï¼‰
        }

        # ä»»å‹™ç‹€æ…‹
        self.mission_start_time = None
        self.cleaned_papers = 0
        self.visited_zones = set()  # å·²è¨ªå•å€åŸŸ ID

    def classify_zone(self, zone):
        """
        åˆ†é¡å€åŸŸï¼ˆè§’è½ vs ä¸­é–“ï¼‰

        ç°¡åŒ–ï¼šå‡è¨­ä¸­é–“å€åŸŸè§’åº¦åœ¨ 45Â°, 135Â°, 225Â°, 315Â° é™„è¿‘
        """
        angle = zone['angle']

        # æª¢æŸ¥æ˜¯å¦æ¥è¿‘ä¸­é–“ï¼ˆå‡è¨­ä¸­é–“åœ¨ 0Â° æ–¹å‘ï¼Œéœ€æ ¹æ“šå¯¦éš›èª¿æ•´ï¼‰
        center_angles = [0, 90, 180, 270]

        for center_angle in center_angles:
            angle_diff = abs(angle - center_angle)
            if angle_diff < 20:  # Â±20Â° ç¯„åœè¦–ç‚ºå¯èƒ½æ˜¯ä¸­é–“
                # é€²ä¸€æ­¥æª¢æŸ¥è·é›¢ï¼ˆä¸­é–“æ‡‰è©²è¼ƒé ï¼‰
                if zone['distance'] > 1.0:
                    return 'center'

        return 'corner'

    def should_return_now(self, current_time, zones, cleaned_papers):
        """
        æ±ºç­–ï¼šæ˜¯å¦æ‡‰è©²ç«‹å³è¿”èˆª

        Returns:
            (should_return: bool, reason: str)
        """
        elapsed = current_time - self.mission_start_time
        remaining = self.TIME_TIER_1 - self.RETURN_TIME_MARGIN - elapsed

        unvisited = [z for z in zones if not z['cleaned']]

        # 1. æ™‚é–“ç·Šè¿« - æ¥è¿‘ç¬¬ä¸€ç´šè·
        if remaining < 0:
            # æª¢æŸ¥æ˜¯å¦é”åˆ° 30 ç‰‡é–€æª»
            if cleaned_papers >= self.PAPER_PENALTY_THRESHOLD:
                return True, f"æ™‚é–“å³å°‡è¶…é Tier 1ï¼Œå·²é” {cleaned_papers} ç‰‡ï¼Œç«‹å³è¿”èˆª"
            else:
                # æœªé” 30 ç‰‡ï¼Œæœƒè¢«æ‰“å…«æŠ˜ï¼Œè©•ä¼°æ˜¯å¦å€¼å¾—ç¹¼çºŒ
                if remaining > -20:  # é‚„æœ‰å°‘è¨±æ™‚é–“
                    return False, f"é›–è¶…æ™‚ä½†æœªé” 30 ç‰‡ï¼Œç¹¼çºŒæ¸…æƒ"
                else:
                    return True, f"è¶…æ™‚éå¤šä¸”åƒ… {cleaned_papers} ç‰‡ï¼Œè¿”èˆªæ­¢æ"

        # 2. æ‰€æœ‰è§’è½å€åŸŸå·²è¨ªå• + ç´™å±‘å……è¶³
        corner_zones = [z for z in zones if self.classify_zone(z) == 'corner']
        unvisited_corners = [z for z in corner_zones if not z['cleaned']]

        if not unvisited_corners and cleaned_papers >= self.PAPER_PENALTY_THRESHOLD:
            return True, f"æ‰€æœ‰è§’è½å·²è¨ªå•ï¼Œ{cleaned_papers} ç‰‡å……è¶³ï¼Œè¿”èˆª"

        # 3. æ‰€æœ‰å€åŸŸå·²è¨ªå•
        if not unvisited:
            return True, f"æ‰€æœ‰å€åŸŸå·²è¨ªå•ï¼Œ{cleaned_papers} ç‰‡ï¼Œè¿”èˆª"

        # 4. æ™‚é–“å³å°‡é€²å…¥ä¸‹ä¸€ç´šè·
        if elapsed > self.TIME_TIER_2 - self.RETURN_TIME_MARGIN:
            return True, f"æ¥è¿‘ Tier 2 é‚Šç•Œï¼Œ{cleaned_papers} ç‰‡ï¼Œè¿”èˆª"

        return False, None

    def select_next_zone(self, zones, current_time):
        """
        æ™ºèƒ½é¸æ“‡ä¸‹ä¸€å€‹å€åŸŸ

        ç­–ç•¥ï¼š
        1. å„ªå…ˆè¨ªå•è§’è½ï¼ˆåˆ†æ•¸é«˜ï¼‰
        2. ç¢ºä¿æ‰€æœ‰å€åŸŸéƒ½è‡³å°‘è¨ªå•ä¸€æ¬¡
        3. æ™‚é–“ç·Šè¿«æ™‚é¸æœ€è¿‘çš„
        """
        elapsed = current_time - self.mission_start_time
        remaining = self.TIME_TIER_1 - self.RETURN_TIME_MARGIN - elapsed

        unvisited = [z for z in zones if not z['cleaned']]
        if not unvisited:
            return None

        # æ™‚é–“ç·Šè¿«ï¼ˆ< 40ç§’ï¼‰ï¼šé¸æœ€è¿‘çš„æœªè¨ªå•å€åŸŸ
        if remaining < 40:
            return min(unvisited, key=lambda z: z['distance'])

        # æ™‚é–“å……è¶³ï¼šå„ªå…ˆé¸è§’è½å€åŸŸ
        corner_zones = [z for z in unvisited if self.classify_zone(z) == 'corner']

        if corner_zones:
            # åœ¨è§’è½ä¸­é¸æœ€è¿‘çš„
            return min(corner_zones, key=lambda z: z['distance'])
        else:
            # è§’è½éƒ½è¨ªå•å®Œäº†ï¼Œé¸ä¸­é–“å€åŸŸ
            return min(unvisited, key=lambda z: z['distance'])

    def get_mission_status(self, current_time):
        """ç²å–ä»»å‹™ç‹€æ…‹æ‘˜è¦"""
        elapsed = current_time - self.mission_start_time

        # åˆ¤æ–·ç•¶å‰æ™‚é–“ç´šè·
        if elapsed < self.TIME_TIER_1:
            time_tier = "Tier 1 (æ»¿åˆ†)"
        elif elapsed < self.TIME_TIER_2:
            time_tier = "Tier 2 (æ¬¡ç´š)"
        elif elapsed < self.TIME_TIER_3:
            time_tier = "Tier 3 (å†æ¬¡ç´š)"
        else:
            time_tier = "è¶…æ™‚"

        # æª¢æŸ¥ç´™å±‘æ‡²ç½°
        paper_penalty = "" if self.cleaned_papers >= self.PAPER_PENALTY_THRESHOLD else " [âš ï¸ å…«æŠ˜]"

        return {
            'elapsed': elapsed,
            'time_tier': time_tier,
            'paper_count': self.cleaned_papers,
            'paper_penalty': paper_penalty,
            'visited_count': len(self.visited_zones)
        }
```

### 3.4 èåˆé¿éšœç³»çµ±

```python
class FusedObstacleAvoidance:
    """
    èåˆè¦–è¦ºç´…è‰²åµæ¸¬èˆ‡è¶…è²æ³¢æ¸¬è·çš„å¹³æ»‘é¿éšœ

    ç­–ç•¥ï¼š
    - è¦–è¦ºç´…è‰²ï¼šé«˜å„ªå…ˆç´šï¼Œç·Šæ€¥é¿éšœ
    - è¶…è²æ³¢ï¼šå¹³æ»‘ä¿®æ­£ï¼Œé˜²æ­¢æ’ç‰†
    """

    def __init__(self):
        # è¶…è²æ³¢é¿éšœåƒæ•¸
        self.ULTRASONIC_SAFE_DISTANCE = 30  # cmï¼ˆé–‹å§‹ä¿®æ­£ï¼‰
        self.ULTRASONIC_DANGER_DISTANCE = 15  # cmï¼ˆå¼·åˆ¶æ¸›é€Ÿï¼‰
        self.MAX_CORRECTION_ANGULAR = 0.5   # æœ€å¤§è§’é€Ÿåº¦ä¿®æ­£

    def compute_safe_command(self, base_cmd, red_detector, sensor_data, frame):
        """
        è¨ˆç®—èåˆé¿éšœå¾Œçš„å®‰å…¨æŒ‡ä»¤

        Args:
            base_cmd: åŸºç¤å°èˆªæŒ‡ä»¤ï¼ˆä¾†è‡ªç‹€æ…‹æ©Ÿï¼‰
            red_detector: ç´…è‰²åµæ¸¬å™¨
            sensor_data: è¶…è²æ³¢æ•¸æ“š
            frame: ç•¶å‰å½±åƒ

        Returns:
            VehicleCommand: ä¿®æ­£å¾Œçš„å®‰å…¨æŒ‡ä»¤
        """
        linear = base_cmd.linear
        angular = base_cmd.angular
        vacuum = base_cmd.vacuum_motor

        # 1. è¦–è¦ºç´…è‰²é¿éšœï¼ˆæœ€é«˜å„ªå…ˆ - è¦†å¯«æ‰€æœ‰æŒ‡ä»¤ï¼‰
        is_red, red_angle = red_detector.is_red_ahead(frame)
        if is_red and linear > 0:  # åªåœ¨å‰é€²æ™‚é¿ç´…
            # ç·Šæ€¥é¿éšœï¼šå¾Œé€€ + å¤§è§’åº¦è½‰å‘
            return VehicleCommand(-0.3, 0.8 if red_angle > 0 else -0.8, vacuum)

        # 2. è¶…è²æ³¢å¹³æ»‘é¿ç‰†
        left_dist = sensor_data.left_distance if sensor_data else 100
        right_dist = sensor_data.right_distance if sensor_data else 100

        # è¨ˆç®—å·¦å³ä¿®æ­£é‡ï¼ˆè¶Šè¿‘ä¿®æ­£è¶Šå¤§ï¼‰
        left_correction = 0
        right_correction = 0

        if left_dist < self.ULTRASONIC_SAFE_DISTANCE:
            # å·¦å´å¤ªè¿‘ï¼Œå‘å³ä¿®æ­£
            left_correction = (self.ULTRASONIC_SAFE_DISTANCE - left_dist) / self.ULTRASONIC_SAFE_DISTANCE
            left_correction *= self.MAX_CORRECTION_ANGULAR

        if right_dist < self.ULTRASONIC_SAFE_DISTANCE:
            # å³å´å¤ªè¿‘ï¼Œå‘å·¦ä¿®æ­£
            right_correction = -(self.ULTRASONIC_SAFE_DISTANCE - right_dist) / self.ULTRASONIC_SAFE_DISTANCE
            right_correction *= self.MAX_CORRECTION_ANGULAR

        # èåˆä¿®æ­£
        total_correction = left_correction + right_correction
        modified_angular = angular + total_correction

        # 3. æ¥è¿‘å±éšªè·é›¢æ™‚æ¸›é€Ÿ
        min_dist = min(left_dist, right_dist)
        speed_factor = 1.0

        if min_dist < self.ULTRASONIC_DANGER_DISTANCE:
            speed_factor = 0.4  # æ¸›é€Ÿåˆ° 40%
        elif min_dist < self.ULTRASONIC_SAFE_DISTANCE:
            # ç·šæ€§æ¸›é€Ÿ
            speed_factor = 0.4 + 0.6 * (min_dist - self.ULTRASONIC_DANGER_DISTANCE) / \
                          (self.ULTRASONIC_SAFE_DISTANCE - self.ULTRASONIC_DANGER_DISTANCE)

        modified_linear = linear * speed_factor

        # é™åˆ¶è§’é€Ÿåº¦ç¯„åœ
        modified_angular = np.clip(modified_angular, -1.0, 1.0)

        return VehicleCommand(modified_linear, modified_angular, vacuum)
```

### 3.5 å€åŸŸå°å‘æ§åˆ¶ç‹€æ…‹æ©Ÿï¼ˆå®Œæ•´ç‰ˆï¼‰

```python
from enum import Enum
import time
import numpy as np

class State(Enum):
    INIT = 0
    SCANNING = 1              # 360Â° æƒæå»ºç«‹å€åŸŸåœ°åœ–
    NAVIGATING_TO_ZONE = 2    # å‰å¾€é»‘è‰²å€åŸŸ
    CLEANING_ZONE = 3         # æ¸…æƒå€åŸŸå…§ç´™å±‘
    AVOIDING_RED = 4          # ç·Šæ€¥é¿ç´…
    RETURNING = 5             # è¿”å›å‡ºå£
    FINISHED = 6

class ZoneBasedAutonomousController:
    """
    åŸºæ–¼é»‘è‰²è† å¸¶å€åŸŸçš„æ™ºèƒ½ç›®æ¨™å°å‘æ§åˆ¶å™¨

    ç‰¹è‰²ï¼š
    - æ™ºèƒ½ä»»å‹™ç®¡ç†ï¼ˆæ™‚é–“ç´šè·ã€ç´™å±‘é–€æª»ã€å€åŸŸå„ªå…ˆç´šï¼‰
    - èåˆé¿éšœï¼ˆè¦–è¦ºç´…è‰² + è¶…è²æ³¢å¹³æ»‘é¿ç‰†ï¼‰
    - è¦–è¦ºé–‰ç’°å°èˆªï¼ˆç„¡ç´¯ç©èª¤å·®ï¼‰
    """

    def __init__(self):
        self.state = State.INIT

        # è¦–è¦ºåµæ¸¬æ¨¡çµ„
        self.black_zone_detector = BlackTapeZoneDetector()
        self.red_zone_detector = RedTapeZoneDetector()
        self.paper_detector = PaperDetector()
        self.entrance_detector = EntranceDetector()

        # æ–°å¢ï¼šä»»å‹™ç®¡ç†å™¨èˆ‡èåˆé¿éšœ
        self.mission_planner = MissionPlanner()
        self.obstacle_avoidance = FusedObstacleAvoidance()

        # å°èˆªç‹€æ…‹
        self.scan_angle = 0
        self.current_target_zone = None

        # æ™‚é–“è¨˜éŒ„
        self.start_time = None
        self.phase_start_time = None
        self.zone_entry_time = None
        self.zone_paper_count = 0  # æœ¬å€åŸŸæ¸…æƒæ•¸é‡

    def run(self):
        """ä¸»æ§åˆ¶è¿´åœˆ"""
        self.start_time = time.time()

        while True:
            # å–å¾—æ„Ÿæ¸¬å™¨è³‡æ–™
            frame = self.camera.get_frame()
            sensor_data = self.arduino.receive_sensor_data()

            # ç‹€æ…‹æ©Ÿ
            if self.state == State.INIT:
                self._state_init(frame)

            elif self.state == State.SCANNING:
                self._state_scanning(frame)

            elif self.state == State.NAVIGATING_TO_ZONE:
                self._state_navigating_to_zone(frame, sensor_data)

            elif self.state == State.CLEANING_ZONE:
                self._state_cleaning_zone(frame)

            elif self.state == State.AVOIDING_RED:
                self._state_avoiding_red(frame)

            elif self.state == State.RETURNING:
                self._state_returning(frame)

            elif self.state == State.FINISHED:
                break

            time.sleep(0.05)  # 20 Hz

        print(f"[å®Œæˆ] ç¸½æ™‚é–“ï¼š{time.time() - self.start_time:.1f} ç§’")
        print(f"[å®Œæˆ] æ¸…æƒç´™å±‘ï¼š{self.cleaned_papers} å€‹")

    def _state_init(self, frame):
        """åˆå§‹åŒ–ï¼šè¨˜éŒ„å…¥å£ç‰¹å¾µ"""
        print("[INIT] è¨˜éŒ„å…¥å£è¦–è¦ºç‰¹å¾µ...")

        # è¨˜éŒ„å…¥å£ï¼ˆç”¨æ–¼è¿”èˆªï¼‰
        self.entrance_detector.memorize_entrance(frame)

        # é€²å…¥æƒæéšæ®µ
        self.state = State.SCANNING
        self.scan_angle = 0
        self.phase_start_time = time.time()
        print("[INITâ†’SCAN] é–‹å§‹ 360Â° æƒæ")

    def _state_scanning(self, frame):
        """æƒæéšæ®µï¼š360Â° å»ºç«‹é»‘è‰²å€åŸŸèˆ‡ç´…è‰²ç¦å€åœ°åœ–"""

        # åŸåœ°æ…¢é€Ÿæ—‹è½‰
        cmd = VehicleCommand(0, 0.3, vacuum_motor=False)
        self.robot.send_command(cmd)

        # åµæ¸¬é»‘è‰²ç´™å±‘å€åŸŸ
        black_zones = self.black_zone_detector.detect_zones(frame, self.scan_angle)
        self.black_zone_detector.add_zones(black_zones)

        # åµæ¸¬ç´…è‰²ç¦å€
        red_zones = self.red_zone_detector.detect_red_zones(frame, self.scan_angle)
        # è¨˜éŒ„ä½†ä¸éœ€è¦å»é‡ï¼ˆåªç”¨æ–¼é¿éšœï¼‰

        # æ›´æ–°æƒæè§’åº¦ï¼ˆ0.3 rad/s * 0.05s â‰ˆ 0.86Â° per cycleï¼‰
        self.scan_angle += 0.86

        # æƒæå®Œæˆæ¢ä»¶
        if self.scan_angle >= 360 or time.time() - self.phase_start_time > 10:
            # åœæ­¢æ—‹è½‰
            self.robot.send_command(VehicleCommand(0, 0, False))
            time.sleep(0.5)

            # å•Ÿå‹•ä»»å‹™è¨ˆæ™‚
            self.mission_planner.mission_start_time = time.time()

            zones = self.black_zone_detector.zones
            print(f"[SCAN] å®Œæˆï¼ç™¼ç¾ {len(zones)} å€‹é»‘è‰²å€åŸŸ")

            # åˆ†é¡å€åŸŸ
            corner_count = sum(1 for z in zones if self.mission_planner.classify_zone(z) == 'corner')
            center_count = len(zones) - corner_count
            print(f"[SCAN] è§’è½: {corner_count} | ä¸­é–“: {center_count}")

            # æ™ºèƒ½é¸æ“‡ç¬¬ä¸€å€‹å€åŸŸï¼ˆå„ªå…ˆè§’è½ï¼‰
            self.current_target_zone = self.mission_planner.select_next_zone(zones, time.time())

            if self.current_target_zone:
                zone_type = self.mission_planner.classify_zone(self.current_target_zone)
                self.state = State.NAVIGATING_TO_ZONE
                self.phase_start_time = time.time()
                print(f"[SCANâ†’NAV] å‰å¾€ {zone_type} å€åŸŸ (è§’åº¦: {self.current_target_zone['angle']:.0f}Â°)")
            else:
                # æ²’æ‰¾åˆ°é»‘è‰²å€åŸŸï¼Œç›´æ¥è¿”å›
                print("[SCANâ†’RETURN] æœªç™¼ç¾ç´™å±‘å€åŸŸï¼Œè¿”èˆª")
                self.state = State.RETURNING

    def _state_navigating_to_zone(self, frame, sensor_data):
        """å°èˆªéšæ®µï¼šå‰å¾€ç›®æ¨™é»‘è‰²å€åŸŸï¼ˆåŠ å…¥èåˆé¿éšœèˆ‡æ™‚é–“ç®¡ç†ï¼‰"""

        # 1. æª¢æŸ¥æ˜¯å¦æ‡‰è©²è¿”èˆªï¼ˆæ™‚é–“ç®¡ç†ï¼‰
        should_return, reason = self.mission_planner.should_return_now(
            time.time(),
            self.black_zone_detector.zones,
            self.mission_planner.cleaned_papers
        )

        if should_return:
            print(f"[NAVâ†’RETURN] {reason}")
            self._print_mission_status()
            self.state = State.RETURNING
            return

        # 2. è¦–è¦ºé–‰ç’°å°èˆª
        black_zones = self.black_zone_detector.detect_zones(frame, 0)

        if black_zones:
            # æ‰¾æœ€æ¥è¿‘ç›®æ¨™æ–¹å‘çš„å€åŸŸ
            closest_zone = min(black_zones, key=lambda z: abs(z['angle']))

            # åˆ°é”å€åŸŸåˆ¤æ–·
            if closest_zone['distance'] < 0.3 and abs(closest_zone['angle']) < 15:
                print(f"[NAVâ†’CLEAN] åˆ°é”å€åŸŸï¼")
                self.state = State.CLEANING_ZONE
                self.zone_entry_time = time.time()
                self.zone_paper_count = 0
                self.robot.send_command(VehicleCommand(0, 0, vacuum_motor=True))
                time.sleep(0.3)
                return

            # è¨ˆç®—åŸºç¤å°èˆªæŒ‡ä»¤
            angle_error = closest_zone['angle']
            if abs(angle_error) > 10:
                base_cmd = VehicleCommand(0.2, angle_error / 30, False)
            else:
                base_cmd = VehicleCommand(0.4, 0, False)

        else:
            # è¦–é‡ä¸­æ²’é»‘è‰²å€åŸŸï¼Œç›²ç›®å‰é€²
            base_cmd = VehicleCommand(0.3, 0, False)

            # è¶…æ™‚ä¿è­·
            if time.time() - self.phase_start_time > 5:
                print("[NAV] è¶…æ™‚ï¼Œé‡æ–°æƒæ")
                self.state = State.SCANNING
                self.scan_angle = 0
                return

        # 3. èåˆé¿éšœä¿®æ­£
        safe_cmd = self.obstacle_avoidance.compute_safe_command(
            base_cmd,
            self.red_zone_detector,
            sensor_data,
            frame
        )

        self.robot.send_command(safe_cmd)

    def _state_cleaning_zone(self, frame):
        """æ¸…æƒéšæ®µï¼šåœ¨é»‘è‰²å€åŸŸå…§æ¸…æƒç´™å±‘ï¼ˆåŠ å…¥è¨ˆæ•¸èˆ‡æ™‚é–“ç®¡ç†ï¼‰"""

        # åµæ¸¬ç´™å±‘
        papers = self.paper_detector.detect_papers(frame)

        if papers:
            # æ›´æ–°è¨ˆæ•¸ï¼ˆç°¡åŒ–ï¼šæ¯çœ‹åˆ°ä¸€æ¬¡åŠ  1ï¼Œå¯¦éš›å¯èƒ½éœ€è¦å»é‡ï¼‰
            self.zone_paper_count += len(papers)

            # æ‰¾æœ€è¿‘çš„ç´™å±‘
            nearest = self.paper_detector.get_nearest_paper(papers)

            # å°æº–ä¸¦é è¿‘
            angle_error = nearest['rel_x']

            if abs(angle_error) > 0.15:
                cmd = VehicleCommand(0.15, angle_error * 0.5, vacuum_motor=True)
            else:
                cmd = VehicleCommand(0.25, 0, vacuum_motor=True)

            self.robot.send_command(cmd)

        else:
            # æ²’çœ‹åˆ°ç´™å±‘ï¼Œå°ç¯„åœæœå°‹
            elapsed = time.time() - self.zone_entry_time

            if elapsed < 5:
                # å‰ 5 ç§’ï¼šç·©æ…¢å‰é€²
                cmd = VehicleCommand(0.2, 0, vacuum_motor=True)
            elif elapsed < 8:
                # 5-8 ç§’ï¼šæ—‹è½‰æœå°‹
                cmd = VehicleCommand(0, 0.3, vacuum_motor=True)
            else:
                # è¶…é 8 ç§’ï¼Œæ¸…æƒå®Œæˆ
                self.mission_planner.cleaned_papers += self.zone_paper_count
                self.mission_planner.visited_zones.add(id(self.current_target_zone))

                print(f"[CLEAN] æœ¬å€: {self.zone_paper_count} ç‰‡ | ç¸½è¨ˆ: {self.mission_planner.cleaned_papers} ç‰‡")

                # æ¨™è¨˜å€åŸŸå·²æ¸…æƒ
                self.black_zone_detector.mark_zone_cleaned(self.current_target_zone)

                # é—œé–‰å¸å¡µå™¨
                self.robot.send_command(VehicleCommand(0, 0, vacuum_motor=False))

                # æ™ºèƒ½é¸æ“‡ä¸‹ä¸€å€åŸŸ
                self.current_target_zone = self.mission_planner.select_next_zone(
                    self.black_zone_detector.zones,
                    time.time()
                )

                # æª¢æŸ¥æ˜¯å¦æ‡‰è©²è¿”èˆª
                should_return, reason = self.mission_planner.should_return_now(
                    time.time(),
                    self.black_zone_detector.zones,
                    self.mission_planner.cleaned_papers
                )

                if should_return:
                    print(f"[CLEANâ†’RETURN] {reason}")
                    self._print_mission_status()
                    self.state = State.RETURNING
                elif self.current_target_zone:
                    zone_type = self.mission_planner.classify_zone(self.current_target_zone)
                    self.state = State.NAVIGATING_TO_ZONE
                    self.phase_start_time = time.time()
                    print(f"[CLEANâ†’NAV] å‰å¾€ {zone_type} å€åŸŸ")
                else:
                    # æ‰€æœ‰å€åŸŸæ¸…å®Œ
                    print("[CLEANâ†’RETURN] æ‰€æœ‰å€åŸŸå®Œæˆ")
                    self._print_mission_status()
                    self.state = State.RETURNING

            self.robot.send_command(cmd)

    def _print_mission_status(self):
        """è¼¸å‡ºä»»å‹™ç‹€æ…‹æ‘˜è¦"""
        status = self.mission_planner.get_mission_status(time.time())
        print(f"[ç‹€æ…‹] æ™‚é–“: {status['elapsed']:.0f}s ({status['time_tier']})")
        print(f"[ç‹€æ…‹] ç´™å±‘: {status['paper_count']}/80{status['paper_penalty']}")
        print(f"[ç‹€æ…‹] å·²è¨ªå•: {status['visited_count']}/{len(self.black_zone_detector.zones)} å€åŸŸ")

    def _state_returning(self, frame):
        """è¿”èˆªéšæ®µï¼šè¦–è¦ºå°èˆªå›åˆ°å…¥å£ï¼ˆåŠ å…¥èåˆé¿éšœï¼‰"""

        # å°‹æ‰¾å…¥å£ç‰¹å¾µ
        entrance_angle = self.entrance_detector.find_entrance_direction(frame)

        if entrance_angle is None:
            # æœªæ‰¾åˆ°å…¥å£ï¼Œæ—‹è½‰æœå°‹
            print("[RETURN] æœå°‹å…¥å£...")
            base_cmd = VehicleCommand(0, 0.4, False)
        elif abs(entrance_angle) > 10:
            # è½‰å‘å°æº–å…¥å£
            base_cmd = VehicleCommand(0.2, entrance_angle / 30, False)
        else:
            # å°æº–å…¥å£ï¼Œå‰é€²
            base_cmd = VehicleCommand(0.5, 0, False)

        # èåˆé¿éšœï¼ˆåŒ…å«ç´…è‰²é¿éšœï¼‰
        safe_cmd = self.obstacle_avoidance.compute_safe_command(
            base_cmd,
            self.red_zone_detector,
            None,  # è¿”èˆªæ™‚å¯èƒ½æ²’æœ‰sensor_data
            frame
        )

        self.robot.send_command(safe_cmd)

        # TODO: åˆ¤æ–·åˆ°é”å…¥å£ï¼ˆç‰¹å¾µåŒ¹é…åº¦é«˜ + è·é›¢è¿‘ï¼‰

        # è¶…æ™‚ä¿è­·
        if time.time() - self.start_time > 180:  # 3åˆ†é˜
            print("[RETURNâ†’FINISH] è¶…æ™‚ï¼Œå¼·åˆ¶çµæŸ")
            self._print_mission_status()
            self.state = State.FINISHED
```

---

## å››ã€æŠ€è¡“å‰µæ–°ç¸½çµ

### 4.1 ä¸éœ€è¦ YOLO
- âœ… å‚³çµ± HSV é¡è‰²åµæ¸¬è¶³å¤ æº–ç¢º
- âœ… é»‘è‰²ã€ç´…è‰²ã€ç™½è‰²åœ¨å„ç¨®å…‰ç·šä¸‹éƒ½å®¹æ˜“è¾¨è­˜
- âœ… Pi4 è™•ç†é€Ÿåº¦å¿«ï¼ˆ30 FPSï¼‰
- âœ… æ˜“æ–¼èª¿è©¦èˆ‡ç¾å ´æ ¡æº–

### 4.2 èåˆé¿éšœç³»çµ±
```
å±¤ç´š 1ï¼ˆæœ€é«˜å„ªå…ˆï¼‰ï¼šè¦–è¦ºç´…è‰²åµæ¸¬ â†’ ç·Šæ€¥é¿éšœ
å±¤ç´š 2ï¼šè¶…è²æ³¢æ¸¬è· â†’ å¹³æ»‘é¿ç‰†ä¿®æ­£
å±¤ç´š 3ï¼šåŸºç¤å°èˆªæŒ‡ä»¤ â†’ ç›®æ¨™è¿½è¹¤
```

**å„ªå‹¢ï¼š**
- ç„¡è¦–è¦ºæ­»è§’æ’ç‰†
- å¹³æ»‘æ§åˆ¶ä¸æ€¥åœ
- ç´…è‰²å„ªå…ˆç¢ºä¿ä¸æ‰£åˆ†

### 4.3 æ™ºèƒ½æ™‚é–“ç®¡ç†
| æƒ…å¢ƒ | ç´™å±‘æ•¸ | æ™‚é–“ | ç­–ç•¥ |
|------|--------|------|------|
| è§’è½æ¸…å®Œ | â‰¥ 30 | < Tier 1 | è¿”èˆªæ‹¿æ»¿åˆ† |
| è§’è½æ¸…å®Œ | < 30 | < Tier 2 | æ¸…ä¸­é–“å€æ‹¼ 30 ç‰‡ |
| æ™‚é–“ç·Šè¿« | â‰¥ 30 | æ¥è¿‘ Tier 1 | ç«‹å³è¿”èˆª |
| æ™‚é–“ç·Šè¿« | < 30 | æ¥è¿‘ Tier 2 | è©•ä¼°æ˜¯å¦å€¼å¾—ç¹¼çºŒ |

### 4.4 å€åŸŸå„ªå…ˆç´š
- **è§’è½å€ï¼ˆ4å€‹ï¼‰ï¼š** é«˜å„ªå…ˆï¼Œå…ˆè¨ªå•ï¼ˆåˆ†æ•¸é«˜ï¼‰
- **ä¸­é–“å€ï¼ˆ1å€‹ï¼‰ï¼š** ä½å„ªå…ˆï¼Œè¦–æ™‚é–“æ±ºå®šï¼ˆåˆ†æ•¸ä½ï¼‰
- **ç¢ºä¿è¦†è“‹ï¼š** æ‰€æœ‰å€åŸŸè‡³å°‘è¨ªå•ä¸€æ¬¡

---

## äº”ã€å¯¦ä½œå„ªå…ˆç´šï¼ˆæ›´æ–°ç‰ˆï¼‰

### Phase 1: è¦–è¦ºåµæ¸¬åŸºç¤ï¼ˆ2-3 å¤©ï¼‰
- [ ] **ç›¸æ©Ÿè¦–è§’ç¢ºèª** - æ‹æ”é»‘/ç´…è† å¸¶ã€ç™½ç´™å±‘ç…§ç‰‡
- [ ] **HSV æ¨™å®šå·¥å…·** - é–‹ç™¼äº’å‹•å¼ HSV èª¿æ•´å·¥å…·
- [ ] é»‘è‰²è† å¸¶åµæ¸¬èª¿æ ¡ï¼ˆHSV ç¯„åœã€é¢ç©é–¾å€¼ï¼‰
- [ ] ç´…è‰²è† å¸¶åµæ¸¬èª¿æ ¡ï¼ˆHSV å…©æ®µç¯„åœï¼‰
- [ ] ç´™å±‘åµæ¸¬èª¿æ ¡ï¼ˆç™½è‰²/æ·ºè‰²ã€å¤§å°éæ¿¾ï¼‰
- [ ] å…¥å£ç‰¹å¾µè¨˜éŒ„ï¼ˆSIFT/ORBï¼‰
- [ ] ç›¸æ©Ÿè¦–è§’ç¢ºèªèˆ‡åƒæ•¸æ ¡æº–

### Phase 2: æƒæèˆ‡å€åŸŸåœ°åœ–ï¼ˆ2 å¤©ï¼‰
- [ ] 360Â° æ—‹è½‰æƒæé‚è¼¯
- [ ] é»‘è‰²å€åŸŸè¨˜éŒ„èˆ‡å»é‡
- [ ] ç´…è‰²ç¦å€è¨˜éŒ„
- [ ] å€åŸŸå„ªå…ˆç´šæ’åºï¼ˆç”±è¿‘åˆ°é ï¼‰

### Phase 3: å€åŸŸå°èˆªï¼ˆ2-3 å¤©ï¼‰
- [ ] è¦–è¦ºä¼ºæœå°èˆªï¼ˆæŒçºŒè¿½è¹¤é»‘è‰²è† å¸¶ï¼‰
- [ ] åˆ°é”åˆ¤æ–·é‚è¼¯
- [ ] ç´…è‰²å³æ™‚é¿éšœ
- [ ] è¶…è²æ³¢è¼”åŠ©é¿éšœ

### Phase 4: å€åŸŸå…§æ¸…æƒï¼ˆ2 å¤©ï¼‰
- [ ] ç´™å±‘è¦–è¦ºè¿½è¹¤
- [ ] å°æº–èˆ‡é è¿‘æ§åˆ¶
- [ ] å°ç¯„åœæœå°‹ç­–ç•¥
- [ ] æ¸…æƒå®Œæˆåˆ¤æ–·

### Phase 5: è¿”èˆªèˆ‡æ•´åˆï¼ˆ2-3 å¤©ï¼‰
- [ ] å…¥å£è¦–è¦ºç‰¹å¾µåŒ¹é…
- [ ] è¿”èˆªå°èˆªé‚è¼¯
- [ ] å®Œæ•´æµç¨‹æ•´åˆæ¸¬è©¦
- [ ] åƒæ•¸å„ªåŒ–ï¼ˆé€Ÿåº¦ã€é–¾å€¼ã€è¶…æ™‚ï¼‰

### Phase 6: ç«¶è³½æº–å‚™ï¼ˆ1-2 å¤©ï¼‰
- [ ] æ¨¡æ“¬å ´åœ°æ¸¬è©¦
- [ ] æ¥µç«¯æƒ…æ³æ¸¬è©¦ï¼ˆå…‰ç·šã€è† å¸¶ä¸æ¸…æ¥šç­‰ï¼‰
- [ ] æ€§èƒ½å„ªåŒ–ï¼ˆæå‡é€Ÿåº¦ã€æ¸›å°‘æ¸…æƒæ™‚é–“ï¼‰

**ç¸½é ä¼°æ™‚é–“ï¼š** 11-15 å¤©

---

## äº”ã€é—œéµå„ªå‹¢

### 5.1 ç›¸æ¯”ç›²ç›®è¦†è“‹ï¼ˆæ²¿ç‰†/èºæ—‹/Zigzagï¼‰
- âœ… **æ•ˆç‡å„ªå…ˆ** - ç›´é”ç´™å±‘é›†ä¸­å€åŸŸï¼Œä¸åšç„¡ç”¨åŠŸ
- âœ… **ç„¡ç´¯ç©èª¤å·®** - è¦–è¦ºé–‰ç’°å°èˆªï¼ŒæŒçºŒä¿®æ­£
- âœ… **å¯é è¿”èˆª** - å…¥å£è¦–è¦ºç‰¹å¾µåŒ¹é…
- âœ… **é©åˆè¨ˆæ™‚è³½** - æœ€å°åŒ–ç§»å‹•è·é›¢èˆ‡æ™‚é–“

### 5.2 ç›¸æ¯”è¤‡é›œ SLAM
- âœ… **å¯¦ä½œç°¡å–®** - ä¸éœ€è¦è¤‡é›œå»ºåœ–èˆ‡å®šä½
- âœ… **å¿«é€Ÿå•Ÿå‹•** - 10 ç§’æƒæå³å¯é–‹å§‹ä»»å‹™
- âœ… **ä½è¨ˆç®—é‡** - Pi4 å¯ç©©å®šé‹è¡Œï¼ˆå·²é©—è­‰æœŸä¸­é™æ§ï¼‰
- âœ… **é­¯æ£’æ€§é«˜** - å³ä½¿éƒ¨åˆ†å€åŸŸåµæ¸¬å¤±æ•—ï¼Œå¯ç¹¼çºŒå…¶ä»–å€åŸŸ

### 5.3 åˆ©ç”¨ç«¶è³½æä¾›çš„è³‡è¨Š
- âœ… **é»‘è‰²è† å¸¶ = å°èˆªç›®æ¨™** - ä¸éœ€è‡ªå·±æ‰¾ç´™å±‘ä½ç½®
- âœ… **ç´…è‰²è† å¸¶ = æ˜ç¢ºç¦å€** - è¦–è¦ºåµæ¸¬å³å¯é¿é–‹
- âœ… **ç´™å±‘é›†ä¸­** - å€åŸŸå…§æœå°‹æ›´é«˜æ•ˆ
- âœ… **å ´åœ°å›ºå®š** - å…¥å£è¦–è¦ºç‰¹å¾µç©©å®š

### 5.4 è¦–è¦ºé–‰ç’°æ§åˆ¶
- âœ… **æŒçºŒè¦–è¦ºç¢ºèª** - ä¸ç´¯ç©èª¤å·®
- âœ… **å³æ™‚åæ‡‰** - ç´…è‰²é¿éšœå»¶é² < 100ms
- âœ… **è‡ªæˆ‘ä¿®æ­£** - åé›¢ç›®æ¨™å¯ç«‹å³è¦–è¦ºç³¾æ­£

---

## å…­ã€é¢¨éšªèˆ‡æ‡‰å°

| é¢¨éšª | å¯èƒ½æ€§ | å½±éŸ¿ | æ‡‰å°ç­–ç•¥ |
|------|--------|------|---------|
| å…‰ç·šè®ŠåŒ–å½±éŸ¿ HSV åµæ¸¬ | ä¸­ | é«˜ | 1. è‡ªå‹•æ›å…‰è£œå„Ÿ<br>2. ç¾å ´æ ¡æº– HSV ç¯„åœ<br>3. å‚™ç”¨ï¼šæ”¾å¯¬é–¾å€¼ |
| é»‘è‰²è† å¸¶åµæ¸¬å¤±æ•— | ä½ | é«˜ | 1. å½¢æ…‹å­¸è™•ç†å¡«è£œæ–·è£‚<br>2. é™ä½é¢ç©é–¾å€¼<br>3. å‚™ç”¨ï¼šæƒææ™‚å¤šè§’åº¦è¨˜éŒ„ |
| ç´™å±‘é¡è‰²èˆ‡åœ°é¢ç›¸è¿‘ | ä¸­ | ä¸­ | 1. èª¿æ•´ HSV/äº®åº¦ç¯„åœ<br>2. ä½¿ç”¨é‚Šç·£æª¢æ¸¬è¼”åŠ©<br>3. å°ç¯„åœç›²ç›®æ¸…æƒ |
| å…¥å£ç‰¹å¾µåŒ¹é…å¤±æ•— | ä½ | ä¸­ | 1. ä½¿ç”¨å¤šç¨®ç‰¹å¾µï¼ˆSIFT + é¡è‰²ï¼‰<br>2. å‚™ç”¨ï¼šè¿”å›åˆå§‹å¤§è‡´ä½ç½® |
| ç´…è‰²é¿éšœéæ–¼æ•æ„Ÿ | ä¸­ | ä½ | èª¿æ•´è·é›¢é–¾å€¼ï¼ˆ50cm â†’ 30cmï¼‰ |
| å€åŸŸæ¸…æƒè¶…æ™‚ | ä½ | ä½ | è¨­å®šåˆç†è¶…æ™‚ï¼ˆ8 ç§’ï¼‰ï¼Œé¿å…å¡æ­» |

---

## ä¸ƒã€æŠ€è¡“å‰µæ–°é»

1. **è† å¸¶æ¨™è¨˜é›™é‡åˆ©ç”¨**
   - é»‘è‰² = ç›®æ¨™å°èˆªé»
   - ç´…è‰² = é¿éšœæ¨™èªŒ
   - å……åˆ†åˆ©ç”¨ç«¶è³½æä¾›çš„è¦–è¦ºè³‡è¨Š

2. **å€åŸŸç›®æ¨™å°å‘ç­–ç•¥**
   - ä¸åŒæ–¼å‚³çµ±è¦†è“‹å¼æ¸…æƒ
   - ç›´é”ç›®æ¨™ï¼Œæ•ˆç‡å„ªå…ˆ
   - é©åˆè¨ˆæ™‚ç«¶è³½

3. **è¦–è¦ºé–‰ç’°å°èˆª**
   - ç„¡éœ€ç·¨ç¢¼å™¨èˆ‡ç²¾ç¢ºå®šä½
   - æŒçºŒè¦–è¦ºä¿®æ­£ï¼Œä¸ç´¯ç©èª¤å·®
   - é­¯æ£’æ€§é«˜

4. **åˆ†å±¤ç‹€æ…‹æ©Ÿè¨­è¨ˆ**
   - æ¸…æ™°çš„ç‹€æ…‹è½‰æ›
   - æ˜“æ–¼èª¿è©¦èˆ‡å„ªåŒ–
   - å¯æ‡‰å°çªç™¼ç‹€æ³ï¼ˆç´…è‰²é¿éšœï¼‰

---

## å…«ã€èˆ‡æ‚¨æœŸä¸­æ–¹æ¡ˆçš„å°æ¯”

| é …ç›® | æœŸä¸­ï¼ˆé™æ§ï¼‰ | æœŸæœ«ï¼ˆè‡ªèµ°ï¼‰ |
|------|------------|------------|
| æ§åˆ¶æ–¹å¼ | äººå·¥é™æ§ | è‡ªä¸»è¦–è¦ºå°èˆª |
| è¦–è¦ºåŠŸèƒ½ | MJPG ä¸²æµï¼ˆäººçœ¼åˆ¤æ–·ï¼‰ | OpenCV è‡ªå‹•åµæ¸¬ |
| å°èˆªç­–ç•¥ | ç„¡ï¼ˆäººå·¥æ±ºç­–ï¼‰ | å€åŸŸç›®æ¨™å°å‘ |
| é¿éšœæ–¹å¼ | äººçœ¼åˆ¤æ–· | ç´…è‰²è¦–è¦º + è¶…è²æ³¢ |
| ç›¸åŒåŸºç¤ | å·®å‹•é©…å‹•ã€Serial é€šè¨Šã€ç©©å®šç¡¬é«” | âœ… å®Œå…¨ç›¸å®¹ |

**å„ªå‹¢ï¼š** æœŸä¸­é©—è­‰çš„ç¡¬é«”èˆ‡é€šè¨Šæ¶æ§‹ç›´æ¥æ²¿ç”¨ï¼Œåªéœ€æ–°å¢è¦–è¦ºæ±ºç­–å±¤ï¼

---

## ä¹ã€ä¸‹ä¸€æ­¥è¡Œå‹•

å»ºè­°æŒ‰ä»¥ä¸‹é †åºæ¨é€²ï¼š

### ç«‹å³é–‹å§‹ï¼ˆPhase 1ï¼‰
1. **ç›¸æ©Ÿè¦–è§’ç¢ºèª**
   - æ‹æ”åœ°é¢é»‘è‰²è† å¸¶ã€ç´…è‰²è† å¸¶ã€ç™½è‰²ç´™å±‘çš„ç…§ç‰‡
   - ç¢ºèªè¦–é‡ç¯„åœèˆ‡æ¸…æ™°åº¦

2. **HSV ç¯„åœæ¨™å®š**
   - ç”¨ OpenCV æ¸¬è©¦å·¥å…·æ‰¾å‡ºæœ€ä½³ HSV ç¯„åœ
   - é»‘è‰²ã€ç´…è‰²ã€ç™½è‰²åˆ†åˆ¥æ¨™å®š

3. **åŸºç¤åµæ¸¬æ¨¡çµ„å¯¦ä½œ**
   - å¯¦ç¾ `BlackTapeZoneDetector`
   - å¯¦ç¾ `RedTapeZoneDetector`
   - å¯¦ç¾ `PaperDetector`
   - å–®ç¨æ¸¬è©¦å„æ¨¡çµ„æº–ç¢ºåº¦

### å»ºè­°
å¦‚æœæ‚¨åŒæ„é€™å€‹æ–¹æ¡ˆï¼Œæˆ‘å¯ä»¥é–‹å§‹å¯¦ä½œç¬¬ä¸€å€‹è¦–è¦ºåµæ¸¬æ¨¡çµ„çš„ç¨‹å¼ç¢¼ã€‚æˆ‘å€‘å¯ä»¥å…ˆå¾é»‘è‰²è† å¸¶åµæ¸¬é–‹å§‹ï¼Œå› ç‚ºé€™æ˜¯æ•´å€‹ç³»çµ±çš„æ ¸å¿ƒï¼
